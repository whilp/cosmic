{modules={["cosmic.benchmark"]={examples={}, file="lib/cosmic/benchmark.tl", functions={{description=" Parse a .tl file and extract Benchmark_* functions.\n Finds all local functions named Benchmark_* and extracts their code.", is_local=true, line=34, name="parse_benchmarks", params={{description="The source code to parse", name="source", param_type="string"}}, returns={{description="List of parsed benchmarks", return_type="{Benchmark}"}}, signature="(source: string): {Benchmark}"}, {description=" Run a single benchmark and measure timing.\n Executes the benchmark code repeatedly, auto-calibrating iterations.", is_local=true, line=155, name="run_benchmark", params={{description="The benchmark to run", name="benchmark", param_type="Benchmark"}, {description="Path to the source file (unused, for API consistency)", name="_file_path", param_type="string"}}, returns={{description="Result with timing statistics", return_type="BenchmarkResult"}}, signature="(benchmark: Benchmark, _file_path: string): BenchmarkResult"}, {description=" Run all benchmarks in a file, optionally filtered by pattern.\n Parses and executes Benchmark_* functions, returning aggregated results.", is_local=true, line=261, name="run", params={{description="Path to the Teal file containing benchmarks", name="file_path", param_type="string"}, {description="Optional Lua pattern to filter benchmark names (e.g., \"concat\" matches Benchmark_string_concat)", name="filter", param_type="string"}}, returns={{description="Result with exit code (0=pass, 1=fail, 2=skip), results, and errors", return_type="RunResult"}}, signature="(file_path: string, filter?: string): RunResult"}, {description=" Format a number with appropriate units for readability.", is_local=true, line=325, name="format_time", params={{description="Nanoseconds", name="ns", param_type="number"}}, returns={{description="Formatted time string", return_type="string"}}, signature="(ns: number): string"}, {description=" Format results for human-readable output (Go-style).\n Creates formatted benchmark output showing iterations and ns/op.", is_local=true, line=342, name="format_results", params={{description="Path to the file that was benchmarked", name="file_path", param_type="string"}, {description="Results from running benchmarks", name="run_result", param_type="RunResult"}}, returns={{description="Formatted output for display", return_type="string"}}, signature="(file_path: string, run_result: RunResult): string"}}, module_doc=" Go-style benchmark testing.\n Parses Benchmark_* functions from Teal files, runs them, and reports timing.\n Similar to Go's testing.B but simplified: functions are called N times automatically.", records={{description=" A parsed benchmark function.", fields={{"name", "string", ""}, {"body", "string", ""}, {"line", "integer", ""}}, line=8, name="Benchmark"}, {description=" Result from running a single benchmark.", fields={{"name", "string", ""}, {"iterations", "integer", ""}, {"ns_per_op", "number", ""}, {"total_ns", "number", ""}, {"error", "string", ""}}, line=15, name="BenchmarkResult"}, {description=" Result from running all benchmarks in a file.", fields={{"exit_code", "integer", ""}, {"results", "{BenchmarkResult}", ""}, {"error", "string", ""}}, line=24, name="RunResult"}, {fields={{"run", "function(file_path: string, filter?: string): RunResult", ""}, {"parse_benchmarks", "function(source: string): {Benchmark}", ""}, {"format_results", "function(file_path: string, run_result: RunResult): string", ""}}, line=377, name="BenchmarkModule"}}}, ["cosmic.doc"]={examples={}, file="lib/cosmic/doc.tl", functions={{description=" Extract leading doc comment (--- or -- style) before a position.\n Scans backwards from the given position to collect doc comment lines.", is_local=true, line=60, name="extract_doc_comment", params={{description="The source code to search", name="source", param_type="string"}, {description="The position to search backwards from", name="pos", param_type="integer"}, {description="If true, also extract -- style comments (default: false)", name="allow_regular_comments", param_type="boolean"}}, returns={{description="The extracted doc comment, or nil if none found", return_type="string"}}, signature="(source: string, pos: integer, allow_regular_comments?: boolean): string"}, {description=" Extract function signature starting from a given position.\n Finds the opening paren, matches to closing paren, and includes return type.", is_local=true, line=119, name="extract_signature", params={{description="The source code", name="source", param_type="string"}, {description="Position to start searching from", name="start_pos", param_type="integer"}}, returns={{description="The extracted signature (from opening paren to end of line)", return_type="string"}}, signature="(source: string, start_pos: integer): string"}, {description=" Parse @param and @return annotations from doc comment.\n Extracts structured parameter and return information along with description.", is_local=true, line=159, name="parse_annotations", params={{description="The doc comment to parse", name="doc", param_type="string"}}, returns={{description="List of parameters", return_type="{Param}"}, {description="List of return values", return_type="{Return}"}, {description="The description text (non-annotation lines)", return_type="string"}}, signature="(doc: string): {Param}, {Return}, string"}, {description=" Parse a .tl file and extract documentation.\n Extracts module docs, records, functions, and examples from source code.", is_local=true, line=199, name="parse", params={{description="The source code to parse", name="source", param_type="string"}, {description="Path to the file being parsed", name="file_path", param_type="string"}}, returns={{description="Complete documentation for the module", return_type="ModuleDoc"}}, signature="(source: string, file_path: string): ModuleDoc"}, {is_local=true, line=234, name="update_line_num", params={}, returns={}, signature="(new_pos: integer)"}, {description=" Render documentation as markdown.\n Converts parsed documentation into formatted markdown with sections for types, functions, and examples.", is_local=true, line=479, name="render", params={{description="The documentation to render", name="doc", param_type="ModuleDoc"}}, returns={{description="Formatted markdown documentation", return_type="string"}}, signature="(doc: ModuleDoc): string"}, {description=" Parse a .d.tl type declaration file and extract documentation.\n Extracts records, their fields, methods, and documentation comments.", is_local=true, line=658, name="parse_dtl", params={{description="The source code to parse", name="source", param_type="string"}, {description="Path to the file being parsed", name="file_path", param_type="string"}}, returns={{description="Complete documentation for the module", return_type="ModuleDoc"}}, signature="(source: string, file_path: string): ModuleDoc"}, {description=" Parse a file and return structured documentation.\n Reads a Teal file and extracts documentation as a ModuleDoc structure.\n Auto-detects .d.tl files and uses the appropriate parser.", is_local=true, line=858, name="parse_file", params={{description="Path to the Teal file to document", name="file_path", param_type="string"}}, returns={{description="Parsed documentation structure, or nil on error", return_type="ModuleDoc"}, {description="Error message if parsing failed", return_type="string"}}, signature="(file_path: string): ModuleDoc, string"}, {description=" Main entry point: parse file and render markdown.\n Reads a Teal file, extracts documentation, and renders it as markdown.\n Auto-detects .d.tl files and uses the appropriate parser.", is_local=true, line=881, name="render_file", params={{description="Path to the Teal file to document", name="file_path", param_type="string"}}, returns={{description="Success status", return_type="boolean"}, {description="Markdown documentation on success, error message on failure", return_type="string"}}, signature="(file_path: string): boolean, string"}, {description=" Serialize a ModuleDoc to Lua source code.\n Uses cosmo.EncodeLua to generate loadable Lua code.", is_local=true, line=908, name="serialize", params={{description="The documentation to serialize", name="doc", param_type="ModuleDoc"}}, returns={{description="Lua source code representing the ModuleDoc", return_type="string"}}, signature="(doc: ModuleDoc): string"}, {description=" Serialize a DocIndex to Lua source code.", is_local=true, line=920, name="serialize_index", params={{description="The index to serialize", name="index", param_type="DocIndex"}}, returns={{description="Lua source code representing the DocIndex", return_type="string"}}, signature="(index: DocIndex): string"}, {description=" Load a DocIndex from Lua source code.", is_local=true, line=928, name="load_index", params={{description="Lua source code from serialize_index", name="source", param_type="string"}}, returns={{description="The loaded index, or nil on error", return_type="DocIndex"}, {description="Error message if loading failed", return_type="string"}}, signature="(source: string): DocIndex, string"}}, module_doc=" Extract documentation from Teal files and render as markdown.\n Parses doc comments, records, functions, and examples from .tl files.", records={{description=" A function parameter with type and description.", fields={{"name", "string", ""}, {"param_type", "string", ""}, {"description", "string", ""}}, line=5, name="Param"}, {description=" A function return value with type and description.", fields={{"return_type", "string", ""}, {"description", "string", ""}}, line=12, name="Return"}, {description=" Documentation for a function.", fields={{"name", "string", ""}, {"description", "string", ""}, {"params", "{Param}", ""}, {"returns", "{Return}", ""}, {"signature", "string", ""}, {"line", "integer", ""}, {"is_local", "boolean", ""}}, line=18, name="FunctionDoc"}, {description=" Documentation for a record type.", fields={{"name", "string", ""}, {"description", "string", ""}, {"fields", "{{string, string, string}}", ""}, {"line", "integer", ""}}, line=29, name="RecordDoc"}, {description=" Documentation for an example function.", fields={{"name", "string", ""}, {"description", "string", ""}, {"body", "string", ""}, {"expected_output", "string", ""}, {"line", "integer", ""}}, line=37, name="ExampleDoc"}, {description=" Complete documentation for a module.", fields={{"file", "string", ""}, {"module_doc", "string", ""}, {"functions", "{FunctionDoc}", ""}, {"records", "{RecordDoc}", ""}, {"examples", "{ExampleDoc}", ""}}, line=46, name="ModuleDoc"}, {fields={}, line=679, name="RecordName"}, {description=" A documentation index containing all modules.", fields={{"modules", "{string:ModuleDoc}", ""}}, line=913, name="DocIndex"}, {fields={{"parse", "function(source: string, file_path: string): ModuleDoc", ""}, {"parse_dtl", "function(source: string, file_path: string): ModuleDoc", ""}, {"parse_file", "function(file_path: string): ModuleDoc, string", ""}, {"render", "function(doc: ModuleDoc): string", ""}, {"render_file", "function(file_path: string): boolean, string", ""}, {"serialize", "function(doc: ModuleDoc): string", ""}, {"serialize_index", "function(index: DocIndex): string", ""}, {"load_index", "function(source: string): DocIndex, string", ""}}, line=940, name="DocModule"}}}, ["cosmic.docindex"]={examples={}, file="lib/cosmic/docindex.tl", functions={{description=" Generate serialized documentation index from source files.", is_local=true, line=16, name="generate", params={{description="of .tl or .d.tl file paths to process", name="files", param_type="List"}}, returns={{description="Lua source for the index, or nil on error", return_type="Encoded"}, {description="message if generation failed", return_type="Error"}}, signature="(files: {string}): string, string"}, {is_local=true, line=45, name="main", params={}, returns={}, signature="(args: {string}): integer"}}, module_doc=" Generate a serialized documentation index from source files.\n Run directly as a script with source files as arguments.", records={{fields={{"generate", "function(files: {string}): string, string", ""}, {"main", "function(args: {string}): integer", ""}}, line=7, name="DocIndexModule"}}}, ["cosmic.docs"]={examples={}, file="lib/cosmic/docs.tl", functions={{description=" Load the embedded documentation index.", is_local=true, line=76, name="load_index", params={}, returns={{description="The documentation index, or nil if not available", return_type="DocIndex"}, {description="Error message if loading failed", return_type="string"}}, signature="(): DocIndex, string"}, {description=" Check if embedded docs are available.", is_local=true, line=102, name="has_docs", params={}, returns={{description="True if docs are embedded", return_type="boolean"}}, signature="(): boolean"}, {description=" Extract first paragraph from module description.", is_local=true, line=110, name="first_paragraph", params={{description="Full description text", name="text", param_type="string"}}, returns={{description="First paragraph, truncated if needed", return_type="string"}}, signature="(text: string): string"}, {description=" List all available documentation topics.", is_local=true, line=128, name="list_topics", params={}, returns={{description="string}} List of {name, description} pairs, sorted by name", return_type="{{string,"}}, signature="(): {{string, string}}"}, {description=" Render topic list as CLI output.", is_local=true, line=150, name="render_topic_list", params={{description="string}} List of {name, description} pairs", name="topics", param_type="{{string,"}}, returns={{description="Formatted output", return_type="string"}}, signature="(topics: {{string, string}}): string"}, {description=" Render a function as CLI output.", is_local=true, line=180, name="render_function", params={{description="Function documentation", name="func", param_type="FunctionDoc"}}, returns={{description="Formatted output", return_type="string"}}, signature="(func: FunctionDoc): string"}, {description=" Render a record/type as CLI output.", is_local=true, line=230, name="render_record", params={{description="Record documentation", name="rec", param_type="RecordDoc"}}, returns={{description="Formatted output", return_type="string"}}, signature="(rec: RecordDoc): string"}, {description=" Render an example as CLI output.", is_local=true, line=264, name="render_example", params={{description="Example documentation", name="example", param_type="ExampleDoc"}}, returns={{description="Formatted output", return_type="string"}}, signature="(example: ExampleDoc): string"}, {description=" Render a full module as CLI output.", is_local=true, line=309, name="render_module", params={{description="Module name", name="name", param_type="string"}, {description="Module documentation", name="doc", param_type="ModuleDoc"}}, returns={{description="Formatted output", return_type="string"}}, signature="(name: string, doc: ModuleDoc): string"}, {description=" Find a symbol in a module's documentation.", is_local=true, line=356, name="find_symbol", params={{description="Module documentation", name="doc", param_type="ModuleDoc"}, {description="Symbol name to find", name="symbol", param_type="string"}}, returns={{description="Rendered symbol documentation, or nil if not found", return_type="string"}}, signature="(doc: ModuleDoc, symbol: string): string"}, {description=" Main entry point for the docs command.", is_local=true, line=391, name="run", params={{description="Optional query string (module or module.symbol)", name="query", param_type="string"}}, returns={{description="Result with documentation content", return_type="DocsResult"}}, signature="(query?: string): DocsResult"}}, module_doc=" Access embedded documentation from the cosmic binary.\n Provides a CLI interface similar to Go's `go doc` command.\n Documentation is parsed at build time and embedded as a serialized Lua index.", records={{description=" A function parameter.", fields={{"name", "string", ""}, {"param_type", "string", ""}, {"description", "string", ""}}, line=8, name="Param"}, {description=" A function return value.", fields={{"return_type", "string", ""}, {"description", "string", ""}}, line=15, name="Return"}, {description=" Documentation for a function.", fields={{"name", "string", ""}, {"description", "string", ""}, {"params", "{Param}", ""}, {"returns", "{Return}", ""}, {"signature", "string", ""}, {"line", "integer", ""}, {"is_local", "boolean", ""}}, line=21, name="FunctionDoc"}, {description=" Documentation for a record type.", fields={{"name", "string", ""}, {"description", "string", ""}, {"fields", "{{string, string, string}}", ""}, {"line", "integer", ""}}, line=32, name="RecordDoc"}, {description=" Documentation for an example function.", fields={{"name", "string", ""}, {"description", "string", ""}, {"body", "string", ""}, {"expected_output", "string", ""}, {"line", "integer", ""}}, line=40, name="ExampleDoc"}, {description=" Complete documentation for a module.", fields={{"file", "string", ""}, {"module_doc", "string", ""}, {"functions", "{FunctionDoc}", ""}, {"records", "{RecordDoc}", ""}, {"examples", "{ExampleDoc}", ""}}, line=49, name="ModuleDoc"}, {description=" A documentation index containing all modules.", fields={{"modules", "{string:ModuleDoc}", ""}}, line=58, name="DocIndex"}, {description=" Result from a docs operation.", fields={{"ok", "boolean", ""}, {"output", "string", ""}}, line=63, name="DocsResult"}, {fields={{"run", "function(query?: string): DocsResult", ""}, {"has_docs", "function(): boolean", ""}, {"list_topics", "function(): {{string, string}}", ""}, {"load_index", "function(): DocIndex, string", ""}, {"render_module", "function(name: string, doc: ModuleDoc): string", ""}}, line=464, name="DocsModule"}}}, ["cosmic.embed"]={examples={}, file="lib/cosmic/embed.tl", functions={{description=" Embed files into a copy of the cosmic executable.\n Creates a new executable with files appended as a zip archive.\n The original executable is copied and files are added to the end as a zip.", is_local=true, line=27, name="run", params={{description="List of file paths to embed", name="files", param_type="{string}"}, {description="Output path for the new executable (defaults to \"cosmic\")", name="output", param_type="string"}, {description="Path to the executable to copy (defaults to arg[-1])", name="exe_path", param_type="string"}}, returns={{description="Result with ok status, message, and file count", return_type="EmbedResult"}}, signature="(files: {string}, output?: string, exe_path?: string): EmbedResult"}}, module_doc=" Embed files into cosmic executable.\n Creates a copy of the cosmic executable with files appended as a zip archive.", records={{description=" Result returned from embed operation.", fields={{"ok", "boolean", ""}, {"message", "string", ""}, {"file_count", "integer", ""}}, line=8, name="EmbedResult"}, {description=" Appender interface for adding files to a ZIP archive.", fields={{"add", "function(self: ZipAppender, name: string, content: string): boolean, string", ""}, {"close", "function(self: ZipAppender)", ""}}, line=15, name="ZipAppender"}, {fields={{"path", "string", ""}, {"content", "string", ""}, {"stored_name", "string", ""}}, line=40, name="FileToEmbed"}, {fields={{"run", "function(files: {string}, output?: string, exe_path?: string): EmbedResult", ""}}, line=104, name="EmbedModule"}}}, ["cosmic.example"]={examples={}, file="lib/cosmic/example.tl", functions={{description=" Parse a .tl file and extract Example_* functions with their expected output.\n Finds all local functions named Example_* and extracts their code and -- Output: comments.", is_local=true, line=32, name="parse_examples", params={{description="The source code to parse", name="source", param_type="string"}}, returns={{description="List of parsed examples", return_type="{Example}"}}, signature="(source: string): {Example}"}, {is_local=true, line=41, name="count_lines", params={}, returns={}, signature="(s: string, start_pos: integer, end_pos: integer): integer"}, {description=" Run a single example and capture its output.\n Executes the example code and compares actual output with expected output.", is_local=true, line=184, name="run_example", params={{description="The example to run", name="example", param_type="Example"}, {description="Path to the source file (for context)", name="file_path", param_type="string"}}, returns={{description="Result with pass/fail status and output comparison", return_type="ExampleResult"}}, signature="(example: Example, file_path: string): ExampleResult"}, {is_local=true, line=218, name="capture_print", params={}, returns={}, signature="(...: any)"}, {is_local=true, line=227, name="capture_write", params={}, returns={}, signature="(...: any): FILE, string, integer"}, {description=" Run all examples in a file.\n Parses and executes all Example_* functions, returning aggregated results.", is_local=true, line=264, name="run", params={{description="Path to the Teal file containing examples", name="file_path", param_type="string"}}, returns={{description="Result with exit code (0=pass, 1=fail, 2=skip), results, and errors", return_type="RunResult"}}, signature="(file_path: string): RunResult"}, {description=" Format results for human-readable output.\n Creates formatted test output showing PASS/FAIL/SKIP with expected vs actual output.", is_local=true, line=311, name="format_results", params={{description="Path to the file that was tested", name="file_path", param_type="string"}, {description="Results from running examples", name="run_result", param_type="RunResult"}}, returns={{description="Formatted output for display", return_type="string"}}, signature="(file_path: string, run_result: RunResult): string"}}, module_doc=" Go-style executable example testing.\n Parses Example_* functions from Teal files, runs them, and verifies output.", records={{description=" A parsed example function with its expected output.", fields={{"name", "string", ""}, {"body", "string", ""}, {"expected_output", "string", ""}, {"line", "integer", ""}}, line=5, name="Example"}, {description=" Result from running a single example.", fields={{"name", "string", ""}, {"passed", "boolean", ""}, {"expected", "string", ""}, {"actual", "string", ""}, {"error", "string", ""}}, line=13, name="ExampleResult"}, {description=" Result from running all examples in a file.", fields={{"exit_code", "integer", ""}, {"results", "{ExampleResult}", ""}, {"error", "string", ""}}, line=22, name="RunResult"}, {fields={{"run", "function(file_path: string): RunResult", ""}, {"parse_examples", "function(source: string): {Example}", ""}, {"format_results", "function(file_path: string, run_result: RunResult): string", ""}}, line=355, name="ExampleModule"}}}, ["cosmic.fetch"]={examples={}, file="lib/cosmic/fetch.tl", functions={{is_local=true, line=24, name="do_fetch", params={}, returns={}, signature="(url: string, opts?: Opts): Result"}, {description=" Fetch a URL and return structured result.", is_local=true, line=47, name="Fetch", params={{description="URL to fetch", name="url", param_type="string"}, {description="optional fetch options (retry, headers, etc.)", name="opts", param_type="Opts"}}, returns={{description="fetch result with ok, status, headers, body, or error", return_type="Result"}}, signature="(url: string, opts?: Opts): Result"}}, module_doc=" Structured HTTP fetch with optional retry.\n Wraps cosmo.Fetch with structured results to prevent accidentally discarding errors.", records={{description=" Result from a fetch operation.", fields={{"ok", "boolean", ""}, {"status", "number", ""}, {"headers", "{string:string}", ""}, {"body", "string", ""}, {"error", "string", ""}}, line=8, name="Result"}, {fields={{"headers", "{string:string}", ""}, {"maxresponse", "number", ""}, {"max_attempts", "number", ""}, {"max_delay", "number", ""}, {"should_retry", "function(Result): boolean", ""}}, line=16, name="Opts"}, {fields={{"Fetch", "function(url: string, opts?: Opts): Result", ""}, {"Opts", "Opts", ""}, {"Result", "Result", ""}}, line=68, name="fetch"}}}, ["cosmic.init"]={examples={}, file="lib/cosmic/init.tl", functions={{description=" Run a main function and exit with its return code.\n Calls the provided function only if running as main script.\n Writes error message to stderr and exits with the returned code.", is_local=true, line=20, name="main", params={{description="The main function to execute", name="fn", param_type="MainFn"}}, returns={}, signature="(fn: MainFn)"}}, module_doc=" Cosmopolitan Lua utilities.\n Main entry point and utilities for cosmic modules.", records={{description=" Environment with standard output and error streams.", fields={{"stdout", "FILE", ""}, {"stderr", "FILE", ""}}, line=7, name="Env"}, {fields={{"_VERSION", "string", ""}, {"_DESCRIPTION", "string", ""}, {"main", "function(fn: MainFn)", ""}}, line=28, name="cosmic"}}}, ["cosmic.spawn"]={examples={{body="\n  local spawn = require(\"cosmic.spawn\")\n  local h = spawn.spawn({\"echo\", \"hello world\"})\n  local ok, out = h:read()\n  print(out)\n  -- Output:\n  -- hello world\n", description=" Example_spawn demonstrates basic process spawning", expected_output="hello world\n", line=241, name="Example_spawn"}, {body="\n  local spawn = require(\"cosmic.spawn\")\n  local h = spawn.spawn({\"cat\"}, {stdin = \"hello from stdin\"})\n  local ok, out = h:read()\n  print(out)\n  -- Output:\n  -- hello from stdin\n", description=" Example_spawn_stdin demonstrates passing stdin to a process", expected_output="hello from stdin\n", line=251, name="Example_spawn_stdin"}, {body="\n  local spawn = require(\"cosmic.spawn\")\n  local h = spawn.spawn({\"sh\", \"-c\", \"exit 0\"})\n  local code = h:wait()\n  print(\"exit code:\", code)\n  -- Output:\n  -- exit code:\t0\n", description=" Example_spawn_exit_code demonstrates checking exit codes", expected_output="exit code:\t0\n", line=261, name="Example_spawn_exit_code"}}, file="lib/cosmic/spawn.tl", functions={{is_local=true, line=32, name="make_pipe", params={}, returns={}, signature="(fd: number): Pipe"}, {is_local=true, line=75, name="spawn", params={}, returns={}, signature="(argv: {string}, opts?: SpawnOpts): SpawnHandle, string"}, {description=" Write data to the pipe.", is_local=false, line=41, name="pipe:write", params={{description="The data to write", name="data", param_type="string"}}, returns={{description="The number of bytes written", return_type="number"}}, signature="(data: string): number"}, {description=" Read data from the pipe.\n If size is provided, reads up to that many bytes. Otherwise, reads until EOF.", is_local=false, line=49, name="pipe:read", params={{description="Optional number of bytes to read", name="size", param_type="number"}}, returns={{description="The data read from the pipe", return_type="string"}}, signature="(size?: number): string"}, {description=" Wait for the process to exit and return its exit code.\n Closes stdin and reads/closes stdout and stderr before waiting.", is_local=false, line=198, name="handle:wait", params={}, returns={{description="The exit code if the process exited normally", return_type="number"}, {description="Error message if the process terminated abnormally", return_type="string"}}, signature="(): number, string"}, {description=" Read output from the process.\n If size is specified, reads that many bytes and returns the data as a string.\n If size is not specified, reads all output, waits for process to exit, and returns\n success status, output, and exit code.", is_local=false, line=219, name="handle:read", params={{description="Optional number of bytes to read", name="size", param_type="number"}}, returns={{description="Success status (true if exit code is 0) or output string if size specified", return_type="boolean|string"}, {description="The stdout output from the process", return_type="string"}, {description="The exit code of the process", return_type="number"}}, signature="(size?: number): boolean | string, string, number"}}, module_doc=" Process spawning utilities.\n Spawn external processes with control over stdin, stdout, and stderr.", records={{description=" Pipe for reading/writing process I/O.", fields={{"fd", "number", ""}, {"write", "function(self: Pipe, data: string): number", ""}, {"read", "function(self: Pipe, size?: number): string", ""}, {"close", "function(self: Pipe)", ""}}, line=6, name="Pipe"}, {description=" Handle for a spawned process.", fields={{"pid", "number", ""}, {"stdin", "Pipe", ""}, {"stdout", "Pipe", ""}, {"stderr", "Pipe", ""}, {"wait", "function(self: SpawnHandle): number, string", ""}, {"read", "function(self: SpawnHandle, size?: number): boolean | string, string, number", ""}}, line=14, name="SpawnHandle"}, {description=" Options for spawning a process.", fields={{"stdin", "string | number", ""}, {"stdout", "number", ""}, {"stderr", "number", ""}, {"env", "{string}", ""}, {"cwd", "string", ""}}, line=24, name="SpawnOpts"}, {fields={{"spawn", "function(argv: {string}, opts?: SpawnOpts): SpawnHandle, string", ""}, {"__call", "function(self: SpawnModule, argv: {string}, opts?: SpawnOpts): SpawnHandle, string", ""}}, line=270, name="SpawnModule"}}}, ["cosmic.teal"]={examples={}, file="lib/cosmic/teal.tl", functions={{description=" Get default include directories for cosmic type definitions.\n Returns paths to bundled and local type definition directories.", is_local=true, line=45, name="get_default_include_dirs", params={}, returns={{description="List of default include directory paths", return_type="{string}"}}, signature="(): {string}"}, {description=" Process a Teal file: read, setup paths, run tl.process_string.\n Returns ProcessResult with tl_result on success, or error on failure.", is_local=true, line=82, name="process_file", params={{description="Path to the Teal file to process", name="input_path", param_type="string"}, {description="Directories to search for type definitions", name="include_dirs", param_type="{string}"}, {description="If true, use lax mode; if false, use strict mode", name="lax", param_type="boolean"}}, returns={{description="Processing result with tl_result or error", return_type="ProcessResult"}}, signature="(input_path: string, include_dirs: {string}, lax: boolean): ProcessResult"}, {description=" Collect errors from tl result (syntax_errors and type_errors).\n Converts Teal's error format to cosmic's Issue format.", is_local=true, line=141, name="collect_errors", params={{description="The result from tl.process_string", name="result", param_type="TlResult"}, {description="Path to the source file for error reporting", name="input_path", param_type="string"}}, returns={{description="List of issues converted from TlErrors", return_type="{Issue}"}}, signature="(result: TlResult, input_path: string): {Issue}"}, {description=" Compile a Teal file to Lua code.\n Uses lax mode for permissive compilation. Preserves shebang if present.", is_local=true, line=180, name="compile", params={{description="Path to the Teal file to compile", name="input_path", param_type="string"}, {description="Compilation options (include_dirs, gen_target, gen_compat)", name="opts", param_type="CompileOpts"}}, returns={{description="Result with ok status, generated Lua code, and any errors", return_type="CompileResult"}}, signature="(input_path: string, opts: CompileOpts): CompileResult"}, {description=" Type-check a Teal file.\n Uses strict mode for thorough type checking. Collects errors and warnings.", is_local=true, line=211, name="check", params={{description="Path to the Teal file to check", name="input_path", param_type="string"}, {description="Type-checking options (include_dirs)", name="opts", param_type="CheckOpts"}}, returns={{description="Result with ok status, warnings, and errors", return_type="CheckResult"}}, signature="(input_path: string, opts: CheckOpts): CheckResult"}, {description=" Format issues for human-readable output.\n Creates formatted strings like \"file.tl:10:5: error: message\".", is_local=true, line=243, name="format_issues", params={{description="List of issues to format", name="issues", param_type="{Issue}"}}, returns={{description="Formatted issues, one per line", return_type="string"}}, signature="(issues: {Issue}): string"}}, module_doc=" Teal compilation and type-checking.\n --compile uses lax mode for permissive compilation.\n --check uses strict mode for thorough type checking.", records={{description=" A compiler or type checker issue.", fields={{"file", "string", ""}, {"line", "integer", ""}, {"column", "integer", ""}, {"message", "string", ""}, {"severity", "string", ""}}, line=8, name="Issue"}, {description=" Options for compiling Teal to Lua.", fields={{"include_dirs", "{string}", ""}, {"gen_target", "string", ""}, {"gen_compat", "string", ""}}, line=17, name="CompileOpts"}, {description=" Options for type-checking Teal files.", fields={{"include_dirs", "{string}", ""}}, line=24, name="CheckOpts"}, {description=" Result from compiling a Teal file.", fields={{"ok", "boolean", ""}, {"code", "string", ""}, {"errors", "{Issue}", ""}}, line=29, name="CompileResult"}, {description=" Result from type-checking a Teal file.", fields={{"ok", "boolean", ""}, {"warnings", "{Issue}", ""}, {"errors", "{Issue}", ""}}, line=36, name="CheckResult"}, {description=" Error from the Teal compiler.", fields={{"msg", "string", ""}, {"filename", "string", ""}, {"y", "integer", ""}, {"x", "integer", ""}}, line=54, name="TlError"}, {description=" Result from Teal's process_string function.", fields={{"syntax_errors", "{TlError}", ""}, {"type_errors", "{TlError}", ""}, {"warnings", "{TlError}", ""}, {"ast", "any", ""}}, line=62, name="TlResult"}, {description=" Internal result from processing a Teal file.", fields={{"tl_result", "TlResult", ""}, {"shebang", "string", ""}, {"error", "Issue", ""}}, line=70, name="ProcessResult"}, {fields={{"compile", "function(input_path: string, opts?: CompileOpts): CompileResult", ""}, {"check", "function(input_path: string, opts?: CheckOpts): CheckResult", ""}, {"format_issues", "function(issues: {Issue}): string", ""}, {"get_default_include_dirs", "function(): {string}", ""}}, line=0x0100, name="TealModule"}}}, ["cosmic.walk"]={examples={}, file="lib/cosmic/walk.tl", functions={{description=" Walk a directory tree, calling visitor for each entry.\n Recursively traverses subdirectories unless visitor returns false.", is_local=true, line=39, name="walk", params={{description="The directory to walk", name="dir", param_type="string"}, {description="Function called for each file and directory", name="visitor", param_type="Visitor"}, {description="Optional context passed to visitor function", name="ctx", param_type="T"}}, returns={{description="The context object, potentially modified by visitor", return_type="T"}}, signature="(dir: string, visitor: Visitor, ctx?: T): T"}, {description=" Collect file paths matching a Lua pattern.\n Recursively walks directory tree and returns matching file paths.", is_local=true, line=67, name="collect", params={{description="The directory to search", name="dir", param_type="string"}, {description="Lua pattern to match against file basenames", name="pattern", param_type="string"}}, returns={{description="List of full paths to matching files", return_type="{string}"}}, signature="(dir: string, pattern: string): {string}"}, {description=" Recursively collect all files with their Unix permissions.\n Returns a map of relative paths to file information.", is_local=true, line=84, name="collect_all", params={{description="The directory to walk", name="dir", param_type="string"}, {description="Internal: relative path prefix (used during recursion)", name="base", param_type="string"}, {description="Internal: accumulator map (used during recursion)", name="files", param_type="{string:FileInfo}"}}, returns={{description="Map of relative paths to file information", return_type="{string:FileInfo}"}}, signature="(dir: string, base?: string, files?: {string:FileInfo}): {string:FileInfo}"}}, module_doc=" Directory tree walking utilities.\n Recursively traverse directories with visitor pattern or glob matching.", records={{description=" File or directory metadata.", fields={{"mode", "function(self): number", ""}, {"size", "function(self): number", ""}, {"mtim", "function(self): number", ""}}, line=7, name="Stat"}, {description=" Handle for reading directory entries.", fields={{"read", "function(self): string", ""}, {"close", "function(self)", ""}}, line=14, name="DirHandle"}, {description=" File information with Unix permissions.", fields={{"mode", "number", ""}}, line=20, name="FileInfo"}, {fields={{"walk", "function<T>(dir: string, visitor: Visitor, ctx?: T): T", ""}, {"collect", "function(dir: string, pattern: string): {string}", ""}, {"collect_all", "function(dir: string, base?: string, files?: {string:FileInfo}): {string:FileInfo}", ""}}, line=113, name="WalkModule"}}}, ["cosmo.argon2"]={examples={}, file="lib/types/cosmo/argon2.d.tl", functions={{description=" Hashes password.\n This is consistent with the README of the reference implementation:\n >: assert(argon2.hash_encoded(\"password\", \"somesalt\", {\n variant = argon2.variants.argon2_i,\n hash_len = 24,\n t_cost = 2,\n }))\n `salt` is a nonce value used to hash the string.\n `config.m_cost` is the memory hardness in kibibytes, which defaults\n to 4096 (4 mibibytes). It's recommended that this be tuned upwards.\n `config.t_cost` is the number of iterations, which defaults to 3.\n `config.parallelism` is the parallelism factor, which defaults to 1.\n `config.hash_len` is the number of desired bytes in hash output,\n which defaults to 32.\n `config.variant` may be:\n - `argon2.variants.argon2_id` blend of other two methods [default]\n - `argon2.variants.argon2_i` maximize resistance to side-channel attacks\n - `argon2.variants.argon2_d` maximize resistance to gpu cracking attacks", is_local=false, line=0, name="hash_encoded", params={{name="pass", param_type="string"}, {name="salt", param_type="string"}, {name="config", param_type="Config"}}, returns={{return_type="string"}}, signature="(pass: string, salt: string, config: Config): string"}, {description=" Verifies password, e.g.\n >: argon2.verify(\n \"p=4$c29tZXNhbHQ$RdescudvJCsgt3ub+b+dWRWJTmaaJObG\",\n true", is_local=false, line=0, name="verify", params={{name="encoded", param_type="string"}, {name="pass", param_type="string"}}, returns={{return_type="boolean"}}, signature="(encoded: string, pass: string): boolean"}}, module_doc="Type declarations for the `argon2` module.", records={}}, ["cosmo.finger"]={examples={}, file="lib/types/cosmo/finger.d.tl", functions={{description=" Fingerprints IP+TCP SYN packet.\n This returns a hash-like magic number that reflects the SYN packet structure,\n e.g. ordering of options, maximum segment size, etc. We make no guarantees this\n hashing algorithm won't change as we learn more about the optimal way to\n - fingerprint, so be sure to save your syn packets too if you're using this\n feature, in case they need to be rehashed in the future.\n This function is nil/error propagating.", is_local=false, line=0, name="FingerSyn", params={{name="syn_packet_bytes", param_type="string"}}, returns={{return_type="number"}}, signature="(syn_packet_bytes: string): number"}, {description=" Fingerprints IP+TCP SYN packet.\n If synfinger is a known hard-coded magic number, then one of the following\n strings may be returned:\n - `\"LINUX\"`\n - `\"WINDOWS\"`\n - `\"XNU\"`\n - `\"NETBSD\"`\n - `\"FREEBSD\"`\n - `\"OPENBSD\"`\n If this function returns `nil`, then one thing you can do to help is file an\n issue and share with us your SYN packet specimens. The way we prefer to receive\n them is in `EncodeLua(syn_packet_bytes)` format along with details on the\n operating system which you must know.", is_local=false, line=0, name="GetSynFingerOs", params={{name="synfinger", param_type="number"}}, returns={{return_type="\"LINUX\""}}, signature="(synfinger: number): \"LINUX\""}, {description=" Describes IP+TCP SYN packet.\n The layout looks as follows:\n - `TTL:OPTIONS:WSIZE:MSS`\n The `TTL`, `WSIZE`, and `MSS` fields are unsigned decimal fields.\n The `OPTIONS` field communicates the ordering of the commonly used subset of\n tcp options. The following character mappings are defined. TCP options not on\n this list will be ignored.\n - `E`: End of Option list\n - `N`: No-Operation\n - `M`: Maximum Segment Size\n - `K`: Window Scale\n - `O`: SACK Permitted\n - `A`: SACK\n - `e`: Echo (obsolete)\n - `r`: Echo reply (obsolete)\n - `T`: Timestamps\n This function is nil/error propagating.", is_local=false, line=0, name="DescribeSyn", params={{name="syn_packet_bytes", param_type="string"}}, returns={{return_type="string"}}, signature="(syn_packet_bytes: string): string"}}, module_doc="Type declarations for the `finger` module.", records={}}, ["cosmo.getopt"]={examples={}, file="lib/types/cosmo/getopt.d.tl", functions={{description=" Create a new getopt parser for iterating through command-line options.\n The optstring uses standard getopt format:\n - A letter means that option takes no argument\n - A letter followed by : means it requires an argument\n - A letter followed by :: means it takes an optional argument\n The longopts table contains entries like {\"name\", \"has_arg\", \"short\"}:\n - name: the long option name (e.g., \"help\" for --help)\n - has_arg: \"none\", \"required\", or \"optional\"\n - short: the equivalent short option character (e.g., \"h\")\n Example - Basic usage:\n     local parser = getopt.new(arg, \"hvo:\", {\n       {\"help\",    \"none\",     \"h\"},\n       {\"verbose\", \"none\",     \"v\"},\n       {\"output\",  \"required\", \"o\"},\n     })\n     while true do\n       local opt, arg = parser:next()\n       if not opt then break end\n       if opt == \"h\" or opt == \"help\" then\n         print(\"Usage: ...\")\n       elseif opt == \"v\" or opt == \"verbose\" then\n         verbose = true\n       elseif opt == \"o\" or opt == \"output\" then\n         output = arg\n       end\n     end\n     local remaining = parser:remaining()  -- non-option args\n     local unknown = parser:unknown()      -- unrecognized options\n Example - Handling repeated options:\n     local parser = getopt.new(arg, \"e:\", {})\n     local excludes = {}\n     while true do\n       local opt, arg = parser:next()\n       if not opt then break end\n       if opt == \"e\" then\n         table.insert(excludes, arg)\n       end\n     end\n     -- Now excludes contains all -e values: {\"foo\", \"bar\", \"spam\"}", is_local=false, line=0, name="new", params={{name="args", param_type="{string}"}, {name="optstring", param_type="string"}, {name="longopts", param_type="{table}"}}, returns={{return_type="parser"}}, signature="(args: {string}, optstring: string, longopts?: {table}): parser"}}, module_doc="Type declarations for the `getopt` module.", records={{fields={{"next", "function(self: parser): string | nil, string | nil", " Get the next option from the parser.\n Returns the next option character or long name, along with its argument\n if the option takes one. Returns nil when no more options remain.\n If the option is unknown, returns \"?\" as the option name and the unknown\n option string as the argument."}, {"remaining", "function(self: parser): {string}", " Get remaining non-option arguments after all options have been parsed."}, {"unknown", "function(self: parser): {string}", " Get any unknown options that were encountered during parsing."}}, line=0, name="parser"}}}, ["cosmo.goodsocket"]={examples={}, file="lib/types/cosmo/goodsocket.d.tl", functions={{description=" Creates a socket with modern TCP optimizations enabled.\n This function wraps GoodSocket() which automatically enables performance\n features like TCP Fast Open, Quick ACK, and other optimizations based on\n whether you're creating a client or server socket.\n Example:\n local gs = require(\"cosmo.goodsocket\")\n local unix = require(\"cosmo.unix\")\n -- Create a TCP client socket\n local fd = assert(gs.socket(gs.AF_INET, gs.SOCK_STREAM, gs.IPPROTO_TCP, false))\n unix.close(fd)\n -- Create a TCP server socket with 30 second timeout\n local fd = assert(gs.socket(gs.AF_INET, gs.SOCK_STREAM, gs.IPPROTO_TCP, true, 30))\n unix.close(fd)", is_local=false, line=0, name="socket", params={{name="family", param_type="number"}, {name="type", param_type="number"}, {name="protocol", param_type="number"}, {name="isserver", param_type="boolean"}, {name="timeout", param_type="number"}}, returns={{return_type="number"}}, signature="(family: number, type: number, protocol: number, isserver: boolean, timeout?: number): number"}}, module_doc="Type declarations for the `goodsocket` module.", records={{description="Constants defined in the goodsocket module.", fields={{"AF_INET", "number", ""}, {"AF_INET6", "number", ""}, {"AF_UNIX", "number", ""}, {"AF_UNSPEC", "number", ""}, {"SOCK_STREAM", "number", ""}, {"SOCK_DGRAM", "number", ""}, {"SOCK_RAW", "number", ""}, {"SOCK_RDM", "number", ""}, {"SOCK_SEQPACKET", "number", ""}, {"IPPROTO_IP", "number", ""}, {"IPPROTO_TCP", "number", ""}, {"IPPROTO_UDP", "number", ""}, {"IPPROTO_ICMP", "number", ""}, {"IPPROTO_IPV6", "number", ""}, {"IPPROTO_ICMPV6", "number", ""}, {"IPPROTO_RAW", "number", ""}}, line=0, name="goodsocket Constants"}}}, ["cosmo.lsqlite3"]={examples={}, file="lib/types/cosmo/lsqlite3.d.tl", functions={{description=" Opens (or creates if it does not exist) an SQLite database with name filename\n and returns its handle as userdata (the returned object should be used for all\n further method calls in connection with this specific database, see Database\n methods). Example:\n myDB = lsqlite3.open('MyDatabase.sqlite3')  -- open\n -- do some database calls...\n myDB:close()  -- close\n In case of an error, the function returns `nil`, an error code and an error message.\n Since `0.9.4`, there is a second optional `flags` argument to `lsqlite3.open`.\n See https://www.sqlite.org/c3ref/open.html for an explanation of these flags and options.\n local db = lsqlite3.open('foo.db', lsqlite3.OPEN_READWRITE + lsqlite3.OPEN_CREATE + lsqlite3.OPEN_SHAREDCACHE)", is_local=false, line=0, name="open", params={{name="filename", param_type="string"}, {name="flags", param_type="number"}}, returns={{return_type="Database"}}, signature="(filename: string, flags?: number): Database"}, {description=" Opens an SQLite database in memory and returns its handle as userdata. In case\n of an error, the function returns `nil`, an error code and an error message.\n (In-memory databases are volatile as they are never stored on disk.)", is_local=false, line=0, name="open_memory", params={}, returns={{return_type="Database"}}, signature="(): Database"}, {is_local=false, line=0, name="lversion", params={}, returns={{return_type="string"}}, signature="(): string"}, {is_local=false, line=0, name="version", params={}, returns={{return_type="string"}}, signature="(): string"}}, module_doc="Type declarations for the `lsqlite3` module.", records={{description="Constants defined in the lsqlite3 module.", fields={{"OK", "number", ""}, {"ERROR", "number", ""}, {"INTERNAL", "number", ""}, {"PERM", "number", ""}, {"ABORT", "number", ""}, {"BUSY", "number", ""}, {"LOCKED", "number", ""}, {"NOMEM", "number", ""}, {"READONLY", "number", ""}, {"INTERRUPT", "number", ""}, {"IOERR", "number", ""}, {"CORRUPT", "number", ""}, {"NOTFOUND", "number", ""}, {"FULL", "number", ""}, {"CANTOPEN", "number", ""}, {"PROTOCOL", "number", ""}, {"EMPTY", "number", ""}, {"SCHEMA", "number", ""}, {"TOOBIG", "number", ""}, {"CONSTRAINT", "number", ""}, {"MISMATCH", "number", ""}, {"MISUSE", "number", ""}, {"NOLFS", "number", ""}, {"FORMAT", "number", ""}, {"RANGE", "number", ""}, {"NOTADB", "number", ""}, {"ROW", "number", ""}, {"DONE", "number", ""}, {"CREATE_INDEX", "number", ""}, {"CREATE_TABLE", "number", ""}, {"CREATE_TEMP_INDEX", "number", ""}, {"CREATE_TEMP_TABLE", "number", ""}, {"CREATE_TEMP_TRIGGER", "number", ""}, {"CREATE_TEMP_VIEW", "number", ""}, {"CREATE_TRIGGER", "number", ""}, {"CREATE_VIEW", "number", ""}, {"DELETE", "number", ""}, {"DROP_INDEX", "number", ""}, {"DROP_TABLE", "number", ""}, {"DROP_TEMP_INDEX", "number", ""}, {"DROP_TEMP_TABLE", "number", ""}, {"DROP_TEMP_TRIGGER", "number", ""}, {"DROP_TEMP_VIEW", "number", ""}, {"DROP_TRIGGER", "number", ""}, {"DROP_VIEW", "number", ""}, {"INSERT", "number", ""}, {"PRAGMA", "number", ""}, {"READ", "number", ""}, {"SELECT", "number", ""}, {"TRANSACTION", "number", ""}, {"UPDATE", "number", ""}, {"ATTACH", "number", ""}, {"DETACH", "number", ""}, {"ALTER_TABLE", "number", ""}, {"REINDEX", "number", ""}, {"ANALYZE", "number", ""}, {"CREATE_VTABLE", "number", ""}, {"DROP_VTABLE", "number", ""}, {"FUNCTION", "number", ""}, {"SAVEPOINT", "number", ""}, {"OPEN_CREATE", "number", ""}, {"OPEN_PRIVATECACHE", "number", ""}, {"OPEN_FULLMUTEX", "number", ""}, {"OPEN_NOMUTEX", "number", ""}, {"OPEN_MEMORY", "number", ""}, {"OPEN_URI", "number", ""}, {"OPEN_READWRITE", "number", ""}, {"OPEN_READONLY", "number", ""}, {"OPEN_SHAREDCACHE", "number", ""}, {"TEXT", "number", ""}, {"BLOB", "number", ""}, {"NULL", "number", ""}, {"FLOAT", "number", ""}}, line=0, name="lsqlite3 Constants"}}}, ["cosmo.maxmind"]={examples={}, file="lib/types/cosmo/maxmind.d.tl", functions={{is_local=false, line=0, name="open", params={{name="filepath", param_type="string"}}, returns={{return_type="Db"}}, signature="(filepath: string): Db"}}, module_doc="Type declarations for the `maxmind` module.", records={{fields={{"lookup", "function(self: Db, ip: number): Result", ""}}, line=0, name="Db"}, {fields={{"get", "function(self: Result): any", ""}, {"netmask", "function(self: Result): number", ""}}, line=0, name="Result"}}}, ["cosmo.path"]={examples={}, file="lib/types/cosmo/path.d.tl", functions={{description=" Strips final component of path, e.g.\n path       dirname\n \n .          .\n ..         .\n /          /\n usr        .\n /usr/      /\n /usr/lib   /usr\n /usr/lib/  /usr", is_local=false, line=0, name="dirname", params={{name="str", param_type="string"}}, returns={{return_type="string"}}, signature="(str: string): string"}, {description=" Returns final component of path, e.g.\n path       basename\n \n .          .\n ..         ..\n /          /\n usr        usr\n /usr/      usr\n /usr/lib   lib\n /usr/lib/  lib", is_local=false, line=0, name="basename", params={{name="str", param_type="string"}}, returns={{return_type="string"}}, signature="(str: string): string"}, {description=" Concatenates path components, e.g.\n x          y         joined\n \n /          /         /\n /usr       lib       /usr/lib\n /usr/      lib       /usr/lib\n /usr/lib   /lib      /lib\n You may specify 1+ arguments.\n Specifying no arguments will raise an error. If `nil` arguments are specified,\n then they're skipped over. If exclusively `nil` arguments are passed, then `nil`\n is returned. Empty strings behave similarly to `nil`, but unlike `nil` may\n coerce a trailing slash.", is_local=false, line=0, name="join", params={{name="str", param_type="string"}, {name="...", param_type="string"}}, returns={{return_type="string"}}, signature="(str?: string, ...: string): string"}, {description=" Returns `true` if path exists.\n This function is inclusive of regular files, directories, and special files.\n Symbolic links are followed are resolved. On error, `false` is returned.", is_local=false, line=0, name="exists", params={{name="path", param_type="string"}}, returns={{return_type="boolean"}}, signature="(path: string): boolean"}, {description=" Returns `true` if path exists and is regular file.\n Symbolic links are not followed. On error, `false` is returned.", is_local=false, line=0, name="isfile", params={{name="path", param_type="string"}}, returns={{return_type="boolean"}}, signature="(path: string): boolean"}, {description=" Returns `true` if path exists and is directory.\n Symbolic links are not followed. On error, `false` is returned.", is_local=false, line=0, name="isdir", params={{name="path", param_type="string"}}, returns={{return_type="boolean"}}, signature="(path: string): boolean"}, {description=" Returns `true` if path exists and is symbolic link.\n Symbolic links are not followed. On error, `false` is returned.", is_local=false, line=0, name="islink", params={{name="path", param_type="string"}}, returns={{return_type="boolean"}}, signature="(path: string): boolean"}}, module_doc="Type declarations for the `path` module.", records={}}, ["cosmo.re"]={examples={}, file="lib/types/cosmo/re.d.tl", functions={{description=" Searches for regular expression match in text.\n This is a shorthand notation roughly equivalent to:\n preg = re.compile(regex)\n patt = preg:search(re, text)\n - `re.BASIC`\n - `re.ICASE`\n - `re.NEWLINE`\n - `re.NOSUB`\n - `re.NOTBOL`\n - `re.NOTEOL`\n This has exponential complexity. Please use `re.compile()` to compile your regular expressions once from `/.init.lua`. This API exists for convenience. This isn't recommended for prod.\n This uses POSIX extended syntax by default.", is_local=false, line=0, name="search", params={{name="regex", param_type="string"}, {name="text", param_type="string"}, {name="flags", param_type="number"}}, returns={{return_type="string"}}, signature="(regex: string, text: string, flags?: number): string"}, {description=" Compiles regular expression.\n - `re.BASIC`\n - `re.ICASE`\n - `re.NEWLINE`\n - `re.NOSUB`\n This has an O(2^) cost. Consider compiling regular expressions once\n from your `/.init.lua` file.\n If regex is an untrusted user value, then `unix.setrlimit` should be\n used to impose cpu and memory quotas for security.\n This uses POSIX extended syntax by default.", is_local=false, line=0, name="compile", params={{name="regex", param_type="string"}, {name="flags", param_type="number"}}, returns={{return_type="Regex"}}, signature="(regex: string, flags?: number): Regex"}}, module_doc="Type declarations for the `re` module.", records={{fields={{"errno", "function(self: Errno): number", " - `unix.NOMATCH` No match\n - `unix.BADPAT` Invalid regex\n - `unix.ECOLLATE` Unknown collating element\n - `unix.ECTYPE` Unknown character class name\n - `unix.EESCAPE` Trailing backslash\n - `unix.ESUBREG` Invalid back reference\n - `unix.EBRACK` Missing `]`\n - `unix.EPAREN` Missing `)`\n - `unix.EBRACE` Missing `}`\n - `unix.BADBR` Invalid contents of `{}`\n - `unix.ERANGE` Invalid character range.\n - `unix.ESPACE` Out of memory\n - `unix.BADRPT` Repetition not preceded by valid expression"}, {"doc", "function(self: Errno): string", ""}, {"__tostring", "function(self: Errno): string", " Delegates to `re.Errno:doc()`."}}, line=0, name="Errno"}, {fields={{"search", "function(self: Regex, str: string, flags?: number): string", " Executes precompiled regular expression.\n Returns nothing (`nil`) if the pattern doesn't match anything. Otherwise it\n pushes the matched substring and any parenthesis-captured values too. Flags may\n contain `re.NOTBOL` or `re.NOTEOL` to indicate whether or not text should be\n considered at the start and/or end of a line.\n - `re.NOTBOL`\n - `re.NOTEOL`\n This has an O() cost."}}, line=0, name="Regex"}, {description="Constants defined in the re module.", fields={{"NOMATCH", "number", ""}, {"BADPAT", "number", ""}, {"ECOLLATE", "number", ""}, {"ECTYPE", "number", ""}, {"EESCAPE", "number", ""}, {"ESUBREG", "number", ""}, {"EBRACK", "number", ""}, {"EPAREN", "number", ""}}, line=0, name="re Constants"}}}, ["cosmo.unix"]={examples={}, file="lib/types/cosmo/unix.d.tl", functions={{description=" Opens file.\n Returns a file descriptor integer that needs to be closed, e.g.\n fd = assert(unix.open(\"/etc/passwd\", unix.O_RDONLY))\n print(unix.read(fd))\n unix.close(fd)\n `flags` should have one of:\n - `O_RDONLY`:     open for reading (default)\n - `O_WRONLY`:     open for writing\n - `O_RDWR`:       open for reading and writing\n The following values may also be OR'd into `flags`:\n - `O_CREAT`      create file if it doesn't exist\n - `O_TRUNC`      automatic ftruncate(fd,0) if exists\n - `O_CLOEXEC`    automatic close() upon execve()\n - `O_EXCL`       exclusive access (see below)\n - `O_APPEND`     open file for append only\n - `O_NONBLOCK`   asks read/write to fail with EAGAIN rather than block\n - `O_DIRECTORY`  useful for stat'ing (hint on UNIX but required on NT)\n - `O_NOFOLLOW`   fail if it's a symlink (zero on Windows)\n - `O_UNLINK`     automatically delete file upon close()\n - `O_SYNC`       makes file operations synchronize appropriately\n - `O_RSYNC`      synchronize read() operations\n - `O_DSYNC`      synchronize write() operations\n - `O_DIRECT`     it's complicated (not supported on Apple and OpenBSD)\n - `O_NOATIME`    don't record access time (zero on non-Linux)\n There are three regular combinations for the above flags:\n - `O_RDONLY`: Opens existing file for reading. If it doesn't exist\n then nil is returned and errno will be `ENOENT` (or in some other\n cases `ENOTDIR`).\n - `O_WRONLY|O_CREAT|O_TRUNC`: Creates file. If it already exists,\n then the existing copy is destroyed and the opened file will\n start off with a length of zero. This is the behavior of the\n traditional creat() system call.\n - `O_WRONLY|O_CREAT|O_EXCL`: Create file only if doesn't exist\n already. If it does exist then `nil` is returned along with\n `errno` set to `EEXIST`.\n `dirfd` defaults to to `unix.AT_FDCWD` and may optionally be set to\n a directory file descriptor to which `path` is relative.\n Returns `ENOENT` if `path` doesn't exist.\n Returns `ENOTDIR` if `path` contained a directory component that\n wasn't a directory\n .", is_local=false, line=0, name="open", params={{name="path", param_type="string"}, {name="flags", param_type="number"}, {name="mode", param_type="number"}, {name="dirfd", param_type="number"}}, returns={{return_type="number"}}, signature="(path: string, flags: number, mode?: number, dirfd?: number): number"}, {description=" Closes file descriptor.\n This function should never be called twice for the same file\n descriptor, regardless of whether or not an error happened. The file\n descriptor is always gone after close is called. So it technically\n always succeeds, but that doesn't mean an error should be ignored.\n For example, on NFS a close failure could indicate data loss.\n Closing does not mean that scheduled i/o operations have been\n completed. You'd need to use fsync() or fdatasync() beforehand to\n ensure that. You shouldn't need to do that normally, because our\n close implementation guarantees a consistent view, since on systems\n where it isn't guaranteed (like Windows) close will implicitly sync.\n File descriptors are automatically closed on exit().\n Returns `EBADF` if `fd` wasn't valid.\n Returns `EINTR` possibly maybe.\n Returns `EIO` if an i/o error occurred.", is_local=false, line=0, name="close", params={{name="fd", param_type="number"}}, returns={{return_type="boolean"}}, signature="(fd: number): boolean"}, {description=" Reads from file descriptor.\n This function returns empty string on end of file. The exception is\n if `bufsiz` is zero, in which case an empty returned string means\n the file descriptor works.", is_local=false, line=0, name="read", params={{name="fd", param_type="number"}, {name="bufsiz", param_type="number"}, {name="offset", param_type="number"}}, returns={{return_type="string"}}, signature="(fd: number, bufsiz?: number, offset?: number): string"}, {description=" Writes to file descriptor.", is_local=false, line=0, name="write", params={{name="fd", param_type="number"}, {name="data", param_type="string"}, {name="offset", param_type="number"}}, returns={{return_type="number"}}, signature="(fd: number, data: string, offset?: number): number"}, {description=" Invokes `_Exit(exitcode)` on the process. This will immediately\n halt the current process. Memory will be freed. File descriptors\n will be closed. Any open connections it owns will be reset. This\n function never returns.", is_local=false, line=0, name="exit", params={{name="exitcode", param_type="number"}}, returns={}, signature="(exitcode?: number)"}, {description=" Returns raw environment variables.\n This allocates and constructs the C/C++ `environ` variable as a Lua\n table consisting of string keys and string values.\n This data structure preserves casing. On Windows NT, by convention,\n environment variable keys are treated in a case-insensitive way. It\n is the responsibility of the caller to consider this.\n This data structure preserves valueless variables. It's possible on\n both UNIX and Windows to have an environment variable without an\n equals, even though it's unusual.\n This data structure preserves duplicates. For example, on Windows,\n there's some irregular uses of environment variables such as how the\n command prompt inserts multiple environment variables with empty\n string as keys, for its internal bookkeeping.", is_local=false, line=0, name="environ", params={}, returns={{return_type="{string:string | nil}"}}, signature="(): {string:string | nil}"}, {description=" Sets environment variable.\n This wraps the C `setenv()` function to allow Lua scripts to set\n environment variables.\n @overload fun(name: string, value: string, overwrite?: boolean): nil, error: unix.Errno", is_local=false, line=0, name="setenv", params={{description="environment variable name", name="name", param_type="string"}, {description="value to set", name="value", param_type="string"}, {description="if false, won't overwrite existing variables (defaults to true)", name="overwrite?", param_type="boolean"}}, returns={{return_type="true"}}, signature="(name?: any, value?: any, overwrite?: any)"}, {description=" Unsets environment variable.\n This wraps the C `unsetenv()` function to allow Lua scripts to remove\n environment variables.\n @overload fun(name: string): nil, error: unix.Errno", is_local=false, line=0, name="unsetenv", params={{description="environment variable name to unset", name="name", param_type="string"}}, returns={{return_type="true"}}, signature="(name?: any)"}, {description=" Clears all environment variables.\n This wraps the C `clearenv()` function to allow Lua scripts to remove\n all environment variables at once.\n @overload fun(): nil, error: unix.Errno", is_local=false, line=0, name="clearenv", params={}, returns={{return_type="true"}}, signature="()"}, {description=" Gets login name of current user.\n This wraps the C `getlogin()` function to retrieve the login name\n associated with the current session.\n @overload fun(): nil, error: unix.Errno", is_local=false, line=0, name="getlogin", params={}, returns={{description="login name", return_type="string"}}, signature="()"}, {description=" Creates a new process mitosis style.\n This system call returns twice. The parent process gets the nonzero\n pid. The child gets zero.\n Here's a simple usage example of creating subprocesses, where we\n fork off a child worker from a main process hook callback to do some\n independent chores, such as sending an HTTP request back to redbean.\n -- as soon as server starts, make a fetch to the server\n -- then signal redbean to shutdown when fetch is complete\n local onServerStart = function()\n if assert(unix.fork()) == 0 then\n local ok, headers, body = Fetch('http://127.0.0.1:8080/test')\n unix.kill(unix.getppid(), unix.SIGTERM)\n unix.exit(0)\n end\n end\n OnServerStart = onServerStart\n We didn't need to use `wait()` here, because (a) we want redbean to go\n back to what it was doing before as the `Fetch()` completes, and (b)\n redbean's main process already has a zombie collector. However it's\n a moot point, since once the fetch is done, the child process then\n asks redbean to gracefully shutdown by sending SIGTERM its parent.\n This is actually a situation where we *must* use fork, because the\n purpose of the main redbean process is to call accept() and create\n workers. So if we programmed redbean to use the main process to send\n a blocking request to itself instead, then redbean would deadlock\n and never be able to accept() the client.\n While deadlocking is an extreme example, the truth is that latency\n issues can crop up for the same reason that just cause jitter\n instead, and as such, can easily go unnoticed. For example, if you\n do soemething that takes longer than a few milliseconds from inside\n your redbean heartbeat, then that's a few milliseconds in which\n redbean is no longer concurrent, and tail latency is being added to\n its ability to accept new connections. fork() does a great job at\n solving this.\n If you're not sure how long something will take, then when in doubt,\n fork off a process. You can then report its completion to something\n like SQLite. Redbean makes having lots of processes cheap. On Linux\n they're about as lightweight as what heavyweight environments call\n greenlets. You can easily have 10,000 Redbean workers on one PC.\n Here's some benchmarks for fork() performance across platforms:\n Linux 5.4 fork      l:     97,200    31,395  [metal]\n FreeBSD 12 fork     l:    236,089    78,841  [vmware]\n Darwin 20.6 fork    l:    295,325    81,738  [metal]\n NetBSD 9 fork       l:  5,832,027 1,947,899  [vmware]\n OpenBSD 6.8 fork    l: 13,241,940 4,422,103  [vmware]\n Windows10 fork      l: 18,802,239 6,360,271  [metal]\n One of the benefits of using `fork()` is it creates an isolation\n barrier between the different parts of your app. This can lead to\n enhanced reliability and security. For example, redbean uses fork so\n it can wipe your ssl keys from memory before handing over control to\n request handlers that process untrusted input. It also ensures that\n if your Lua app crashes, it won't take down the server as a whole.\n Hence it should come as no surprise that `fork()` would go slower on\n operating systems that have more security features. So depending on\n your use case, you can choose the operating system that suits you.", is_local=false, line=0, name="fork", params={}, returns={{return_type="number | number"}}, signature="(): number | number"}, {description=" Performs `$PATH` lookup of executable.\n unix = require 'unix'\n prog = assert(unix.commandv('ls'))\n unix.execve(prog, {prog, '-hal', '.'}, {'PATH=/bin'})\n unix.exit(127)\n If `prog` is an absolute path, then it's returned as-is. If `prog`\n contains slashes then it's not path searched either and will be\n returned if it exists. On Windows, it's recommended that you install\n programs from cosmos to c:/bin/ without any .exe or .com suffix, so\n they can be discovered like they would on UNIX. If you want to find\n a program like notepad on the $PATH using this function, then you\n need to specify \"notepad.exe\" so it includes the extension.", is_local=false, line=0, name="commandv", params={{name="prog", param_type="string"}}, returns={{return_type="string"}}, signature="(prog: string): string"}, {description=" Exits current process, replacing it with a new instance of the\n specified program. `prog` needs to be an absolute path, see\n commandv(). `env` defaults to to the current `environ`. Here's\n a basic usage example:\n unix.execve(\"/bin/ls\", {\"/bin/ls\", \"-hal\"}, {\"PATH=/bin\"})\n unix.exit(127)\n `prog` needs to be the resolved pathname of your executable. You\n can use commandv() to search your `PATH`.\n `args` is a string list table. The first element in `args`\n should be `prog`. Values are coerced to strings. This parameter\n defaults to `{prog}`.\n `env` is a string list table. Values are coerced to strings. No\n ordering requirement is imposed. By convention, each string has its\n key and value divided by an equals sign without spaces. If this\n parameter is not specified, it'll default to the C/C++ `environ`\n variable which is inherited from the shell that launched redbean.\n It's the responsibility of the user to supply a sanitized environ\n when spawning untrusted processes.\n `execve()` is normally called after `fork()` returns `0`. If that isn't\n the case, then your redbean worker will be destroyed.\n This function never returns on success.\n `EAGAIN` is returned if you've enforced a max number of\n processes using `setrlimit(RLIMIT_NPROC)`.", is_local=false, line=0, name="execve", params={{name="prog", param_type="string"}, {name="args", param_type="{string}"}, {name="env", param_type="{string}"}}, returns={{return_type="nil"}, {return_type="Errno"}}, signature="(prog: string, args: {string}, env: {string}): nil, Errno"}, {description=" Executes program with PATH search.\n Unlike `execve()`, this function searches for `prog` in the\n directories listed in the `PATH` environment variable.\n If `argv` is not provided, it defaults to `{prog}`.\n This function never returns on success.", is_local=false, line=0, name="execvp", params={{name="prog", param_type="string"}, {name="argv", param_type="{string}"}}, returns={{return_type="nil"}, {return_type="Errno"}}, signature="(prog: string, argv?: {string}): nil, Errno"}, {description=" Executes program with PATH search and custom environment.\n Like `execvp()` but also allows specifying a custom environment.\n `envp` is a string list table where each string is typically\n in the form `\"KEY=value\"`. If not specified, inherits the\n current environment.\n This function never returns on success.", is_local=false, line=0, name="execvpe", params={{name="prog", param_type="string"}, {name="argv", param_type="{string}"}, {name="envp", param_type="{string}"}}, returns={{return_type="nil"}, {return_type="Errno"}}, signature="(prog: string, argv: {string}, envp?: {string}): nil, Errno"}, {description=" Executes program from file descriptor.\n This allows executing a program that has already been opened,\n which can be useful for executing programs that have been\n verified or for executing APE (Actually Portable Executable)\n binaries.\n `fd` is an open file descriptor pointing to an executable.\n `argv` is the argument vector passed to the program.\n `envp` is the environment. If not specified, inherits the\n current environment.\n This function never returns on success.", is_local=false, line=0, name="fexecve", params={{name="fd", param_type="number"}, {name="argv", param_type="{string}"}, {name="envp", param_type="{string}"}}, returns={{return_type="nil"}, {return_type="Errno"}}, signature="(fd: number, argv: {string}, envp?: {string}): nil, Errno"}, {description=" Spawns a new process.\n Unlike `fork()` + `execve()`, this uses `posix_spawn()` which\n can be more efficient on some platforms.\n `prog` must be an explicit path to the executable.\n `argv` is the argument vector passed to the program.\n `envp` is the environment. If not specified, inherits the\n current environment.\n Returns the child process id on success.", is_local=false, line=0, name="spawn", params={{name="prog", param_type="string"}, {name="argv", param_type="{string}"}, {name="envp", param_type="{string}"}}, returns={{return_type="number"}}, signature="(prog: string, argv: {string}, envp?: {string}): number"}, {description=" Spawns a new process with PATH search.\n Like `spawn()` but searches for `prog` in the directories\n listed in the `PATH` environment variable.\n Returns the child process id on success.", is_local=false, line=0, name="spawnp", params={{name="prog", param_type="string"}, {name="argv", param_type="{string}"}, {name="envp", param_type="{string}"}}, returns={{return_type="number"}}, signature="(prog: string, argv: {string}, envp?: {string}): number"}, {description=" Duplicates file descriptor.\n `newfd` may be specified to choose a specific number for the new\n file descriptor. If it's already open, then the preexisting one will\n be silently closed. `EINVAL` is returned if `newfd` equals `oldfd`.\n `flags` can have `O_CLOEXEC` which means the returned file\n descriptors will be automatically closed upon execve().\n `lowest` defaults to zero and defines the lowest numbered file\n descriptor that's acceptable to use. If `newfd` is specified then\n `lowest` is ignored. For example, if you wanted to duplicate\n standard input, then:\n stdin2 = assert(unix.dup(0, nil, unix.O_CLOEXEC, 3))\n Will ensure that, in the rare event standard output or standard\n error are closed, you won't accidentally duplicate standard input to\n those numbers.", is_local=false, line=0, name="dup", params={{name="oldfd", param_type="number"}, {name="newfd", param_type="number"}, {name="flags", param_type="number"}, {name="lowest", param_type="number"}}, returns={{return_type="number"}}, signature="(oldfd: number, newfd?: number, flags?: number, lowest?: number): number"}, {description=" Creates fifo which enables communication between processes.\n - `O_CLOEXEC`: Automatically close file descriptor upon execve()\n - `O_NONBLOCK`: Request `EAGAIN` be raised rather than blocking\n - `O_DIRECT`: Enable packet mode w/ atomic reads and writes, so long\n as they're no larger than `PIPE_BUF` (guaranteed to be 512+ bytes)\n with support limited to Linux, Windows NT, FreeBSD, and NetBSD.\n Returns two file descriptors: one for reading and one for writing.\n Here's an example of how pipe(), fork(), dup(), etc. may be used\n to serve an HTTP response containing the output of a subprocess.\n local unix = require \"unix\"\n ls = assert(unix.commandv(\"ls\"))\n reader, writer = assert(unix.pipe())\n if assert(unix.fork()) == 0 then\n unix.close(1)\n unix.dup(writer)\n unix.close(writer)\n unix.close(reader)\n unix.execve(ls, {ls, \"-Shal\"})\n unix.exit(127)\n else\n unix.close(writer)\n SetHeader('Content-Type', 'text/plain')\n while true do\n data, err = unix.read(reader)\n if data then\n if data ~= \"\" then\n Write(data)\n else\n break\n end\n elseif err:errno() ~= EINTR then\n Log(kLogWarn, tostring(err))\n break\n end\n end\n assert(unix.close(reader))\n assert(unix.wait())\n end", is_local=false, line=0, name="pipe", params={{name="flags", param_type="number"}}, returns={{return_type="number"}, {return_type="number"}}, signature="(flags?: number): number, number"}, {description=" Waits for subprocess to terminate.\n `pid` defaults to `-1` which means any child process. Setting\n `pid` to `0` is equivalent to `-getpid()`. If `pid < -1` then\n that means wait for any pid in the process group `-pid`. Then\n lastly if `pid > 0` then this waits for a specific process id\n Options may have `WNOHANG` which means don't block, check for\n the existence of processes that are already dead (technically\n speaking zombies) and if so harvest them immediately.\n Returns the process id of the child that terminated. In other\n cases, the returned `pid` is nil and `errno` is non-nil.\n The returned `wstatus` contains information about the process\n exit status. It's a complicated integer and there's functions\n that can help interpret it. For example:\n -- wait for zombies\n -- traditional technique for SIGCHLD handlers\n while true do\n pid, status = unix.wait(-1, unix.WNOHANG)\n if pid then\n if unix.WIFEXITED(status) then\n print('child', pid, 'exited with',\n unix.WEXITSTATUS(status))\n elseif unix.WIFSIGNALED(status) then\n print('child', pid, 'crashed with',\n unix.strsignal(unix.WTERMSIG(status)))\n end\n elseif status:errno() == unix.ECHILD then\n Log(kLogDebug, 'no more zombies')\n break\n else\n Log(kLogWarn, tostring(err))\n break\n end\n end", is_local=false, line=0, name="wait", params={{name="pid", param_type="number"}, {name="options", param_type="number"}}, returns={{return_type="number"}, {return_type="number"}, {return_type="Rusage"}}, signature="(pid?: number, options?: number): number, number, Rusage"}, {description=" Returns `true` if process exited cleanly.", is_local=false, line=0, name="WIFEXITED", params={{name="wstatus", param_type="number"}}, returns={{return_type="boolean"}}, signature="(wstatus: number): boolean"}, {description=" Returns code passed to exit() assuming `WIFEXITED(wstatus)` is true.", is_local=false, line=0, name="WEXITSTATUS", params={{name="wstatus", param_type="number"}}, returns={{return_type="number"}}, signature="(wstatus: number): number"}, {description=" Returns `true` if process terminated due to a signal.", is_local=false, line=0, name="WIFSIGNALED", params={{name="wstatus", param_type="number"}}, returns={{return_type="boolean"}}, signature="(wstatus: number): boolean"}, {description=" Returns signal that caused process to terminate assuming\n `WIFSIGNALED(wstatus)` is `true`.", is_local=false, line=0, name="WTERMSIG", params={{name="wstatus", param_type="number"}}, returns={{return_type="number"}}, signature="(wstatus: number): number"}, {description=" Returns process id of current process.\n This function does not fail.", is_local=false, line=0, name="getpid", params={}, returns={{return_type="number"}}, signature="(): number"}, {description=" Returns process id of parent process.\n This function does not fail.", is_local=false, line=0, name="getppid", params={}, returns={{return_type="number"}}, signature="(): number"}, {description=" Sends signal to process(es).\n The impact of this action can be terminating the process, or\n interrupting it to request something happen.\n `pid` can be:\n - `pid > 0` signals one process by id\n - `== 0`    signals all processes in current process group\n - `-1`      signals all processes possible (except init)\n - `< -1`    signals all processes in -pid process group\n `sig` can be:\n - `0`       checks both if pid exists and we can signal it\n - `SIGINT`  sends ctrl-c keyboard interrupt\n - `SIGQUIT` sends backtrace and exit signal\n - `SIGTERM` sends shutdown signal\n - etc.\n Windows NT only supports the kill() signals required by the ANSI C89\n standard, which are `SIGINT` and `SIGQUIT`. All other signals on the\n Windows platform that are sent to another process via kill() will be\n treated like `SIGKILL`.", is_local=false, line=0, name="kill", params={{name="pid", param_type="number"}, {name="sig", param_type="number"}}, returns={{return_type="boolean"}}, signature="(pid: number, sig: number): boolean"}, {description=" Sends signal to process group.\n This is similar to `kill()` but sends the signal to all processes\n in the specified process group.\n `pgrp` is the process group id. If 0, sends to the calling process's\n process group.\n `sig` can be any signal value (e.g., `SIGTERM`, `SIGKILL`, etc.).", is_local=false, line=0, name="killpg", params={{name="pgrp", param_type="number"}, {name="sig", param_type="number"}}, returns={{return_type="boolean"}}, signature="(pgrp: number, sig: number): boolean"}, {description=" Triggers signal in current process.\n This is pretty much the same as `kill(getpid(), sig)`.", is_local=false, line=0, name="raise", params={{name="sig", param_type="number"}}, returns={{return_type="number"}}, signature="(sig: number): number"}, {description=" Checks if effective user of current process has permission to access file.\n - `AT_SYMLINK_NOFOLLOW`: do not follow symbolic links.", is_local=false, line=0, name="access", params={{name="path", param_type="string"}, {name="how", param_type="number"}, {name="flags", param_type="number"}, {name="dirfd", param_type="number"}}, returns={{return_type="boolean"}}, signature="(path: string, how: number, flags?: number, dirfd?: number): boolean"}, {description=" Makes directory.\n `path` is the path of the directory you wish to create.\n `mode` is octal permission bits, e.g. `0755`.\n Fails with `EEXIST` if `path` already exists, whether it be a\n directory or a file.\n Fails with `ENOENT` if the parent directory of the directory you\n want to create doesn't exist. For making `a/really/long/path/`\n consider using makedirs() instead.\n Fails with `ENOTDIR` if a parent directory component existed that\n wasn't a directory.\n Fails with `EACCES` if the parent directory doesn't grant write\n permission to the current user.\n Fails with `ENAMETOOLONG` if the path is too long.", is_local=false, line=0, name="mkdir", params={{name="path", param_type="string"}, {name="mode", param_type="number"}, {name="dirfd", param_type="number"}}, returns={{return_type="boolean"}}, signature="(path: string, mode?: number, dirfd?: number): boolean"}, {description=" Unlike mkdir() this convenience wrapper will automatically create\n parent parent directories as needed. If the directory already exists\n then, unlike mkdir() which returns EEXIST, the makedirs() function\n will return success.\n `path` is the path of the directory you wish to create.\n `mode` is octal permission bits, e.g. `0755`.", is_local=false, line=0, name="makedirs", params={{name="path", param_type="string"}, {name="mode", param_type="number"}}, returns={{return_type="boolean"}}, signature="(path: string, mode?: number): boolean"}, {description=" Creates a temporary directory with a unique name.\n `template` must end with \"XXXXXX\" which will be replaced with random\n characters to create a unique directory name.\n Returns the path of the created directory.\n Example:\n local tmpdir = unix.mkdtemp(\"/tmp/myapp_XXXXXX\")\n -- tmpdir is now something like \"/tmp/myapp_a3b2c1\"", is_local=false, line=0, name="mkdtemp", params={{name="template", param_type="string"}}, returns={{return_type="string"}}, signature="(template: string): string"}, {description=" Creates a temporary file with a unique name.\n `template` must end with \"XXXXXX\" which will be replaced with random\n characters to create a unique filename.\n Returns both the file descriptor and the path of the created file.\n The file is opened for reading and writing.\n Example:\n local fd, path = unix.mkstemp(\"/tmp/myapp_XXXXXX\")\n unix.write(fd, \"hello\")\n unix.close(fd)\n unix.unlink(path)", is_local=false, line=0, name="mkstemp", params={{name="template", param_type="string"}}, returns={{return_type="number"}, {return_type="string"}}, signature="(template: string): number, string"}, {description=" Changes current directory to `path`.", is_local=false, line=0, name="chdir", params={{name="path", param_type="string"}}, returns={{return_type="boolean"}}, signature="(path: string): boolean"}, {description=" Removes file at `path`.\n If `path` refers to a symbolic link, the link is removed.\n Returns `EISDIR` if `path` refers to a directory. See `rmdir()`.", is_local=false, line=0, name="unlink", params={{name="path", param_type="string"}, {name="dirfd", param_type="number"}}, returns={{return_type="boolean"}}, signature="(path: string, dirfd?: number): boolean"}, {description=" Removes empty directory at `path`.\n Returns `ENOTDIR` if `path` isn't a directory, or a path component\n in `path` exists yet wasn't a directory.", is_local=false, line=0, name="rmdir", params={{name="path", param_type="string"}, {name="dirfd", param_type="number"}}, returns={{return_type="boolean"}}, signature="(path: string, dirfd?: number): boolean"}, {description=" Renames file or directory.", is_local=false, line=0, name="rename", params={{name="oldpath", param_type="string"}, {name="newpath", param_type="string"}, {name="olddirfd", param_type="number"}, {name="newdirfd", param_type="number"}}, returns={{return_type="boolean"}}, signature="(oldpath: string, newpath: string, olddirfd: number, newdirfd: number): boolean"}, {description=" Creates hard link, so your underlying inode has two names.", is_local=false, line=0, name="link", params={{name="existingpath", param_type="string"}, {name="newpath", param_type="string"}, {name="flags", param_type="number"}, {name="olddirfd", param_type="number"}, {name="newdirfd", param_type="number"}}, returns={{return_type="boolean"}}, signature="(existingpath: string, newpath: string, flags: number, olddirfd: number, newdirfd: number): boolean"}, {description=" Creates symbolic link.\n On Windows NT a symbolic link is called a \"reparse point\" and can\n only be created from an administrator account. Your redbean will\n automatically request the appropriate permissions.", is_local=false, line=0, name="symlink", params={{name="target", param_type="string"}, {name="linkpath", param_type="string"}, {name="newdirfd", param_type="number"}}, returns={{return_type="boolean"}}, signature="(target: string, linkpath: string, newdirfd?: number): boolean"}, {description=" Reads contents of symbolic link.\n Note that broken links are supported on all platforms. A symbolic\n link can contain just about anything. It's important to not assume\n that `content` will be a valid filename.\n On Windows NT, this function transliterates `\\` to `/` and\n furthermore prefixes `//?/` to WIN32 DOS-style absolute paths,\n thereby assisting with simple absolute filename checks in addition\n to enabling one to exceed the traditional 260 character limit.", is_local=false, line=0, name="readlink", params={{name="path", param_type="string"}, {name="dirfd", param_type="number"}}, returns={{return_type="string"}}, signature="(path: string, dirfd?: number): string"}, {description=" Returns absolute path of filename, with `.` and `..` components\n removed, and symlinks will be resolved.", is_local=false, line=0, name="realpath", params={{name="path", param_type="string"}}, returns={{return_type="string"}}, signature="(path: string): string"}, {description=" Changes access and/or modified timestamps on file.\n `path` is a string with the name of the file.\n The `asecs` and `ananos` parameters set the access time. If they're\n none or nil, the current time will be used.\n The `msecs` and `mnanos` parameters set the modified time. If\n they're none or nil, the current time will be used.\n The nanosecond parameters (`ananos` and `mnanos`) must be on the\n interval [0,1000000000) or `unix.EINVAL` is raised. On XNU this is\n truncated to microsecond precision. On Windows NT, it's truncated to\n hectonanosecond precision. These nanosecond parameters may also be\n set to one of the following special values:\n - `unix.UTIME_NOW`: Fill this timestamp with current time. This\n feature is not available on old versions of Linux, e.g. RHEL5.\n - `unix.UTIME_OMIT`: Do not alter this timestamp. This feature is\n not available on old versions of Linux, e.g. RHEL5.\n `dirfd` is a file descriptor integer opened with `O_DIRECTORY`\n that's used for relative path names. It defaults to `unix.AT_FDCWD`.\n `flags` may have have any of the following flags bitwise or'd\n - `AT_SYMLINK_NOFOLLOW`: Do not follow symbolic links. This makes it\n possible to edit the timestamps on the symbolic link itself,\n rather than the file it points to.", is_local=false, line=0, name="utimensat", params={{name="path", param_type="string"}, {name="asecs", param_type="number"}, {name="ananos", param_type="number"}, {name="msecs", param_type="number"}, {name="mnanos", param_type="number"}, {name="dirfd", param_type="number"}, {name="flags", param_type="number"}}, returns={{return_type="number"}}, signature="(path: string, asecs: number, ananos: number, msecs: number, mnanos: number, dirfd?: number, flags?: number): number"}, {description=" Changes access and/or modified timestamps on file descriptor.\n `fd` is the file descriptor of a file opened with `unix.open`.\n The `asecs` and `ananos` parameters set the access time. If they're\n none or nil, the current time will be used.\n The `msecs` and `mnanos` parameters set the modified time. If\n they're none or nil, the current time will be used.\n The nanosecond parameters (`ananos` and `mnanos`) must be on the\n interval [0,1000000000) or `unix.EINVAL` is raised. On XNU this is\n truncated to microsecond precision. On Windows NT, it's truncated to\n hectonanosecond precision. These nanosecond parameters may also be\n set to one of the following special values:\n - `unix.UTIME_NOW`: Fill this timestamp with current time.\n - `unix.UTIME_OMIT`: Do not alter this timestamp.\n This system call is currently not available on very old versions of\n Linux, e.g. RHEL5.", is_local=false, line=0, name="futimens", params={{name="fd", param_type="number"}, {name="asecs", param_type="number"}, {name="ananos", param_type="number"}, {name="msecs", param_type="number"}, {name="mnanos", param_type="number"}}, returns={{return_type="number"}}, signature="(fd: number, asecs: number, ananos: number, msecs: number, mnanos: number): number"}, {description=" Changes user and group on file.\n Returns `ENOSYS` on Windows NT.", is_local=false, line=0, name="chown", params={{name="path", param_type="string"}, {name="uid", param_type="number"}, {name="gid", param_type="number"}, {name="flags", param_type="number"}, {name="dirfd", param_type="number"}}, returns={{return_type="boolean"}}, signature="(path: string, uid: number, gid: number, flags?: number, dirfd?: number): boolean"}, {description=" Changes mode bits on file.\n On Windows NT the chmod system call only changes the read-only\n status of a file.", is_local=false, line=0, name="chmod", params={{name="path", param_type="string"}, {name="mode", param_type="number"}, {name="flags", param_type="number"}, {name="dirfd", param_type="number"}}, returns={{return_type="boolean"}}, signature="(path: string, mode: number, flags?: number, dirfd?: number): boolean"}, {description=" Returns current working directory.\n On Windows NT, this function transliterates `\\` to `/` and\n furthermore prefixes `//?/` to WIN32 DOS-style absolute paths,\n thereby assisting with simple absolute filename checks in addition\n to enabling one to exceed the traditional 260 character limit.", is_local=false, line=0, name="getcwd", params={}, returns={{return_type="string"}}, signature="(): string"}, {description=" Recursively removes filesystem path.\n Like `unix.makedirs()` this function isn't actually a system call but\n rather is a Libc convenience wrapper. It's intended to be equivalent\n to using the UNIX shell's `rm -rf path` command.", is_local=false, line=0, name="rmrf", params={{name="path", param_type="string"}}, returns={{return_type="boolean"}}, signature="(path: string): boolean"}, {description=" Manipulates file descriptor.\n `cmd` may be one of:\n - `unix.F_GETFD` Returns file descriptor flags.\n - `unix.F_SETFD` Sets file descriptor flags.\n - `unix.F_GETFL` Returns file descriptor status flags.\n - `unix.F_SETFL` Sets file descriptor status flags.\n - `unix.F_SETLK` Acquires lock on file interval.\n - `unix.F_SETLKW` Waits for lock on file interval.\n - `unix.F_GETLK` Acquires information about lock.\n unix.fcntl(fd:int, unix.F_GETFD)\n  flags:int\n  nil, unix.Errno\n Returns file descriptor flags.\n The returned `flags` may include any of:\n - `unix.FD_CLOEXEC` if `fd` was opened with `unix.O_CLOEXEC`.\n Returns `EBADF` if `fd` isn't open.\n unix.fcntl(fd:int, unix.F_SETFD, flags:int)\n  true\n  nil, unix.Errno\n Sets file descriptor flags.\n `flags` may include any of:\n - `unix.FD_CLOEXEC` to re-open `fd` with `unix.O_CLOEXEC`.\n Returns `EBADF` if `fd` isn't open.\n unix.fcntl(fd:int, unix.F_GETFL)\n  flags:int\n  nil, unix.Errno\n Returns file descriptor status flags.\n `flags & unix.O_ACCMODE` includes one of:\n - `O_RDONLY`\n - `O_WRONLY`\n - `O_RDWR`\n Examples of values `flags & ~unix.O_ACCMODE` may include:\n - `O_NONBLOCK`\n - `O_APPEND`\n - `O_SYNC`\n - `O_NOATIME` on Linux\n - `O_DIRECT` on Linux/FreeBSD/NetBSD/Windows\n Examples of values `flags & ~unix.O_ACCMODE` won't include:\n - `O_CREAT`\n - `O_TRUNC`\n - `O_EXCL`\n - `O_NOCTTY`\n Returns `EBADF` if `fd` isn't open.\n unix.fcntl(fd:int, unix.F_SETFL, flags:int)\n  true\n  nil, unix.Errno\n Changes file descriptor status flags.\n Examples of values `flags` may include:\n - `O_NONBLOCK`\n - `O_APPEND`\n - `O_SYNC`\n - `O_NOATIME` on Linux\n - `O_DIRECT` on Linux/FreeBSD/NetBSD/Windows\n These values should be ignored:\n - `O_RDONLY`, `O_WRONLY`, `O_RDWR`\n - `O_CREAT`, `O_TRUNC`, `O_EXCL`\n - `O_NOCTTY`\n Returns `EBADF` if `fd` isn't open.\n unix.fcntl(fd:int, unix.F_SETLK[, type[, start[, len[, whence]]]])\n unix.fcntl(fd:int, unix.F_SETLKW[, type[, start[, len[, whence]]]])\n  true\n  nil, unix.Errno\n Acquires lock on file interval.\n POSIX Advisory Locks allow multiple processes to leave voluntary\n hints to each other about which portions of a file they're using.\n The command may be:\n - `F_SETLK` to acquire lock if possible\n - `F_SETLKW` to wait for lock if necessary\n `fd` is file descriptor of open() file.\n `type` may be one of:\n - `F_RDLCK` for read lock (default)\n - `F_WRLCK` for read/write lock\n - `F_UNLCK` to unlock\n `start` is 0-indexed byte offset into file. The default is zero.\n `len` is byte length of interval. Zero is the default and it means\n until the end of the file.\n `whence` may be one of:\n - `SEEK_SET` start from beginning (default)\n - `SEEK_CUR` start from current position\n - `SEEK_END` start from end\n Returns `EAGAIN` if lock couldn't be acquired. POSIX says this\n theoretically could also be `EACCES` but we haven't seen this\n behavior on any of our supported platforms.\n Returns `EBADF` if `fd` wasn't open.\n unix.fcntl(fd:int, unix.F_GETLK[, type[, start[, len[, whence]]]])\n  unix.F_UNLCK\n  type, start, len, whence, pid\n  nil, unix.Errno\n Acquires information about POSIX advisory lock on file.\n This function accepts the same parameters as fcntl(F_SETLK) and\n tells you if the lock acquisition would be successful for a given\n range of bytes. If locking would have succeeded, then F_UNLCK is\n returned. If the lock would not have succeeded, then information\n about a conflicting lock is returned.\n Returned `type` may be `F_RDLCK` or `F_WRLCK`.\n Returned `pid` is the process id of the current lock owner.\n This function is currently not supported on Windows.\n Returns `EBADF` if `fd` wasn't open.", is_local=false, line=0, name="fcntl", params={{name="fd", param_type="number"}, {name="cmd", param_type="number"}, {name="...", param_type="any"}}, returns={{return_type="any"}}, signature="(fd: number, cmd: number, ...: any): any"}, {description=" Gets session id.", is_local=false, line=0, name="getsid", params={{name="pid", param_type="number"}}, returns={{return_type="number"}}, signature="(pid: number): number"}, {description=" Gets process group id.", is_local=false, line=0, name="getpgrp", params={}, returns={{return_type="number"}}, signature="(): number"}, {description=" Sets process group id. This is the same as `setpgid(0,0)`.", is_local=false, line=0, name="setpgrp", params={}, returns={{return_type="number"}}, signature="(): number"}, {description=" Sets process group id the modern way.", is_local=false, line=0, name="setpgid", params={{name="pid", param_type="number"}, {name="pgid", param_type="number"}}, returns={{return_type="boolean"}}, signature="(pid: number, pgid: number): boolean"}, {description=" Gets process group id the modern way.", is_local=false, line=0, name="getpgid", params={{name="pid", param_type="number"}}, returns={}, signature="(pid: number)"}, {description=" Sets session id.\n This function can be used to create daemons.\n Fails with `ENOSYS` on Windows NT.", is_local=false, line=0, name="setsid", params={}, returns={{return_type="number"}}, signature="(): number"}, {description=" Daemonizes the current process.\n This function performs the standard Unix daemonization steps:\n forks, creates a new session, and optionally changes directory\n and redirects standard file descriptors.\n `nochdir` if true, the current working directory is not changed\n to `/`. Defaults to false (will change to `/`).\n `noclose` if true, stdin/stdout/stderr are not redirected to\n `/dev/null`. Defaults to false (will redirect to `/dev/null`).\n This is a convenience wrapper that combines `fork()`, `setsid()`,\n and related operations.", is_local=false, line=0, name="daemon", params={{name="nochdir", param_type="boolean"}, {name="noclose", param_type="boolean"}}, returns={{return_type="boolean"}}, signature="(nochdir?: boolean, noclose?: boolean): boolean"}, {description=" Gets real user id.\n On Windows this system call is polyfilled by running `GetUserNameW()`\n through Knuth's multiplicative hash.\n This function does not fail.", is_local=false, line=0, name="getuid", params={}, returns={{return_type="number"}}, signature="(): number"}, {description=" Sets real group id.\n On Windows this system call is polyfilled as getuid().\n This function does not fail.", is_local=false, line=0, name="getgid", params={}, returns={{return_type="number"}}, signature="(): number"}, {description=" Gets effective user id.\n For example, if your redbean is a setuid binary, then getuid() will\n return the uid of the user running the program, and geteuid() shall\n return zero which means root, assuming that's the file owning user.\n On Windows this system call is polyfilled as getuid().\n This function does not fail.", is_local=false, line=0, name="geteuid", params={}, returns={{return_type="number"}}, signature="(): number"}, {description=" Gets effective group id.\n On Windows this system call is polyfilled as getuid().\n This function does not fail.", is_local=false, line=0, name="getegid", params={}, returns={{return_type="number"}}, signature="(): number"}, {description=" Changes root directory.\n Returns `ENOSYS` on Windows NT.", is_local=false, line=0, name="chroot", params={{name="path", param_type="string"}}, returns={{return_type="boolean"}}, signature="(path: string): boolean"}, {description=" Sets user id.\n One use case for this function is dropping root privileges. Should\n you ever choose to run redbean as root and decide not to use the\n `-G` and `-U` flags, you can replicate that behavior in the Lua\n processes you spawn as follows:\n ok, err = unix.setgid(1000)  -- check your /etc/groups\n if not ok then Log(kLogFatal, tostring(err)) end\n ok, err = unix.setuid(1000)  -- check your /etc/passwd\n if not ok then Log(kLogFatal, tostring(err)) end\n If your goal is to relinquish privileges because redbean is a setuid\n binary, then things are more straightforward:\n ok, err = unix.setgid(unix.getgid())\n if not ok then Log(kLogFatal, tostring(err)) end\n ok, err = unix.setuid(unix.getuid())\n if not ok then Log(kLogFatal, tostring(err)) end\n See also the setresuid() function and be sure to refer to your local\n system manual about the subtleties of changing user id in a way that\n isn't restorable.\n Returns `ENOSYS` on Windows NT if `uid` isn't `getuid()`.", is_local=false, line=0, name="setuid", params={{name="uid", param_type="number"}}, returns={{return_type="boolean"}}, signature="(uid: number): boolean"}, {description=" Sets user id for file system ops.", is_local=false, line=0, name="setfsuid", params={{name="uid", param_type="number"}}, returns={{return_type="boolean"}}, signature="(uid: number): boolean"}, {description=" Sets group id.\n Returns `ENOSYS` on Windows NT if `gid` isn't `getgid()`.", is_local=false, line=0, name="setgid", params={{name="gid", param_type="number"}}, returns={{return_type="boolean"}}, signature="(gid: number): boolean"}, {description=" Sets real, effective, and saved user ids.\n If any of the above parameters are -1, then it's a no-op.\n Returns `ENOSYS` on Windows NT.\n Returns `ENOSYS` on Macintosh and NetBSD if `saved` isn't -1.", is_local=false, line=0, name="setresuid", params={{name="real", param_type="number"}, {name="effective", param_type="number"}, {name="saved", param_type="number"}}, returns={{return_type="boolean"}}, signature="(real: number, effective: number, saved: number): boolean"}, {description=" Sets real, effective, and saved group ids.\n If any of the above parameters are -1, then it's a no-op.\n Returns `ENOSYS` on Windows NT.\n Returns `ENOSYS` on Macintosh and NetBSD if `saved` isn't -1.", is_local=false, line=0, name="setresgid", params={{name="real", param_type="number"}, {name="effective", param_type="number"}, {name="saved", param_type="number"}}, returns={{return_type="boolean"}}, signature="(real: number, effective: number, saved: number): boolean"}, {description=" Sets file permission mask and returns the old one.\n This is used to remove bits from the `mode` parameter of functions\n like open() and mkdir(). The masks typically used are 027 and 022.\n Those masks ensure that, even if a file is created with 0666 bits,\n it'll be turned into 0640 or 0644 so that users other than the owner\n can't modify it.\n To read the mask without changing it, try doing this:\n mask = unix.umask(027)\n unix.umask(mask)\n On Windows NT this is a no-op and `mask` is returned.\n This function does not fail.", is_local=false, line=0, name="umask", params={{name="newmask", param_type="number"}}, returns={{return_type="number"}}, signature="(newmask: number): number"}, {description=" Generates a log message, which will be distributed by syslogd.\n `priority` is a bitmask containing the facility value and the level\n value. If no facility value is ORed into priority, then the default\n value set by openlog() is used. If set to NULL, the program name is\n used. Level is one of `LOG_EMERG`, `LOG_ALERT`, `LOG_CRIT`,\n `LOG_ERR`, `LOG_WARNING`, `LOG_NOTICE`, `LOG_INFO`, `LOG_DEBUG`.\n This function currently works on Linux, Windows, and NetBSD. On\n WIN32 it uses the ReportEvent() facility.", is_local=false, line=0, name="syslog", params={{name="priority", param_type="number"}, {name="msg", param_type="string"}}, returns={}, signature="(priority: number, msg: string)"}, {description=" Returns nanosecond precision timestamp from system, e.g.\n >: unix.clock_gettime()\n 1651137352      774458779\n >: Benchmark(unix.clock_gettime)\n 126     393     571     1\n `clock` can be any one of of:\n - `CLOCK_REALTIME` returns a wall clock timestamp represented in\n nanoseconds since the UNIX epoch (~1970). It'll count time in the\n suspend state. This clock is subject to being smeared by various\n adjustments made by NTP. These timestamps can have unpredictable\n discontinuous jumps when clock_settime() is used. Therefore this\n clock is the default clock for everything, even pthread condition\n variables. Cosmopoiltan guarantees this clock will never raise\n `EINVAL` and also guarantees `CLOCK_REALTIME == 0` will always be\n the case. On Windows this maps to GetSystemTimePreciseAsFileTime().\n On platforms with vDSOs like Linux, Windows, and MacOS ARM64 this\n should take about 20 nanoseconds.\n - `CLOCK_MONOTONIC` returns a timestamp with an unspecified epoch,\n that should be when the system was powered on. These timestamps\n shouldn't go backwards. Timestamps shouldn't count time spent in\n the sleep, suspend, and hibernation states. These timestamps won't\n be impacted by clock_settime(). These timestamps may be impacted by\n frequency adjustments made by NTP. Cosmopoiltan guarantees this\n clock will never raise `EINVAL`. MacOS and BSDs use the word\n \"uptime\" to describe this clock. On Windows this maps to\n QueryUnbiasedInterruptTimePrecise().\n - `CLOCK_BOOTTIME` is a monotonic clock returning a timestamp with an\n unspecified epoch, that should be relative to when the host system\n was powered on. These timestamps shouldn't go backwards. Timestamps\n should also include time spent in a sleep, suspend, or hibernation\n state. These timestamps aren't impacted by clock_settime(), but\n they may be impacted by frequency adjustments made by NTP. This\n clock will raise an `EINVAL` error on extremely old Linux distros\n like RHEL5. MacOS and BSDs use the word \"monotonic\" to describe\n this clock. On Windows this maps to QueryInterruptTimePrecise().\n - `CLOCK_MONOTONIC_RAW` returns a timestamp from an unspecified\n epoch. These timestamps don't count time spent in the sleep,\n suspend, and hibernation states. Unlike `CLOCK_MONOTONIC` this\n clock is guaranteed to not be impacted by frequency adjustments or\n discontinuous jumps caused by clock_settime(). Providing this level\n of assurances may make this clock slower than the normal monotonic\n clock. Furthermore this clock may cause `EINVAL` to be raised if\n running on a host system that doesn't provide those guarantees,\n e.g. OpenBSD and MacOS on AMD64.\n - `CLOCK_REALTIME_COARSE` is the same as `CLOCK_REALTIME` except\n it'll go faster if the host OS provides a cheaper way to read the\n wall time. Please be warned that coarse can be really coarse.\n Rather than nano precision, you're looking at `CLK_TCK` precision,\n which can lag as far as 30 milliseconds behind or possibly more.\n Cosmopolitan may fallback to `CLOCK_REALTIME` if a faster less\n accurate clock isn't provided by the system. This clock will raise\n an `EINVAL` error on extremely old Linux distros like RHEL5.\n - `CLOCK_MONOTONIC_COARSE` is the same as `CLOCK_MONOTONIC` except\n it'll go faster if the host OS provides a cheaper way to read the\n unbiased time. Please be warned that coarse can be really coarse.\n Rather than nano precision, you're looking at `CLK_TCK` precision,\n which can lag as far as 30 milliseconds behind or possibly more.\n Cosmopolitan may fallback to `CLOCK_REALTIME` if a faster less\n accurate clock isn't provided by the system. This clock will raise\n an `EINVAL` error on extremely old Linux distros like RHEL5.\n - `CLOCK_PROCESS_CPUTIME_ID` returns the amount of time this process\n was actively scheduled. This is similar to getrusage() and clock().\n Cosmopoiltan guarantees this clock will never raise `EINVAL`.\n - `CLOCK_THREAD_CPUTIME_ID` returns the amount of time this thread\n was actively scheduled. This is similar to getrusage() and clock().\n Cosmopoiltan guarantees this clock will never raise `EINVAL`.\n Returns `EINVAL` if clock isn't supported on platform.\n This function only fails if `clock` is invalid.\n This function goes fastest on Linux and Windows.", is_local=false, line=0, name="clock_gettime", params={{name="clock", param_type="number"}}, returns={{return_type="number"}, {return_type="number"}}, signature="(clock?: number): number, number"}, {description=" Sleeps with nanosecond precision.\n Returns `EINTR` if a signal was received while waiting.", is_local=false, line=0, name="nanosleep", params={{name="seconds", param_type="number"}, {name="nanos", param_type="number"}}, returns={{return_type="number"}, {return_type="number"}}, signature="(seconds: number, nanos?: number): number, number"}, {description=" These functions are used to make programs slower by asking the\n operating system to flush data to the physical medium.", is_local=false, line=0, name="sync", params={}, returns={}, signature="()"}, {description=" These functions are used to make programs slower by asking the\n operating system to flush data to the physical medium.", is_local=false, line=0, name="fsync", params={{name="fd", param_type="number"}}, returns={{return_type="boolean"}}, signature="(fd: number): boolean"}, {description=" These functions are used to make programs slower by asking the\n operating system to flush data to the physical medium.", is_local=false, line=0, name="fdatasync", params={{name="fd", param_type="number"}}, returns={{return_type="boolean"}}, signature="(fd: number): boolean"}, {description=" Seeks to file position.\n `whence` can be one of:\n - `SEEK_SET`: Sets the file position to `offset` [default]\n - `SEEK_CUR`: Sets the file position to `position + offset`\n - `SEEK_END`: Sets the file position to `filesize + offset`\n Returns the new position relative to the start of the file.", is_local=false, line=0, name="lseek", params={{name="fd", param_type="number"}, {name="offset", param_type="number"}, {name="whence", param_type="number"}}, returns={{return_type="number"}}, signature="(fd: number, offset: number, whence?: number): number"}, {description=" Reduces or extends underlying physical medium of file.\n If file was originally larger, content >length is lost.", is_local=false, line=0, name="truncate", params={{name="path", param_type="string"}, {name="length", param_type="number"}}, returns={{return_type="boolean"}}, signature="(path: string, length?: number): boolean"}, {description=" Reduces or extends underlying physical medium of open file.\n If file was originally larger, content >length is lost.", is_local=false, line=0, name="ftruncate", params={{name="fd", param_type="number"}, {name="length", param_type="number"}}, returns={{return_type="boolean"}}, signature="(fd: number, length?: number): boolean"}, {description=" - `AF_INET`: Creates Internet Protocol Version 4 (IPv4) socket.\n - `AF_UNIX`: Creates local UNIX domain socket. On the New Technology\n this requires Windows 10 and only works with `SOCK_STREAM`.\n - `SOCK_STREAM`\n - `SOCK_DGRAM`\n - `SOCK_RAW`\n - `SOCK_RDM`\n - `SOCK_SEQPACKET`\n You may bitwise OR any of the following into `type`:\n - `SOCK_CLOEXEC`\n - `SOCK_NONBLOCK`\n - `0` to let kernel choose [default]\n - `IPPROTO_TCP`\n - `IPPROTO_UDP`\n - `IPPROTO_RAW`\n - `IPPROTO_IP`\n - `IPPROTO_ICMP`", is_local=false, line=0, name="socket", params={{name="family", param_type="number"}, {name="type", param_type="number"}, {name="protocol", param_type="number"}}, returns={{return_type="number"}}, signature="(family?: number, type?: number, protocol?: number): number"}, {description=" Creates bidirectional pipe.\n - `SOCK_STREAM`\n - `SOCK_DGRAM`\n - `SOCK_SEQPACKET`\n You may bitwise OR any of the following into `type`:\n - `SOCK_CLOEXEC`\n - `SOCK_NONBLOCK`", is_local=false, line=0, name="socketpair", params={{name="family", param_type="number"}, {name="type", param_type="number"}, {name="protocol", param_type="number"}}, returns={{return_type="number"}, {return_type="number"}}, signature="(family?: number, type?: number, protocol?: number): number, number"}, {description=" Binds socket.\n `ip` and `port` are in host endian order. For example, if you\n wanted to listen on `1.2.3.4:31337` you could do any of these\n unix.bind(sock, 0x01020304, 31337)\n unix.bind(sock, ParseIp('1.2.3.4'), 31337)\n unix.bind(sock, 1 << 24 | 0 << 16 | 0 << 8 | 1, 31337)\n `ip` and `port` both default to zero. The meaning of bind(0, 0)\n is to listen on all interfaces with a kernel-assigned ephemeral\n port number, that can be retrieved and used as follows:\n sock = assert(unix.socket())  -- create ipv4 tcp socket\n assert(unix.bind(sock))       -- all interfaces ephemeral port\n ip, port = assert(unix.getsockname(sock))\n print(\"listening on ip\", FormatIp(ip), \"port\", port)\n assert(unix.listen(sock))\n while true do\n client, clientip, clientport = assert(unix.accept(sock))\n print(\"got client ip\", FormatIp(clientip), \"port\", clientport)\n unix.close(client)\n end\n Further note that calling `unix.bind(sock)` is equivalent to not\n calling bind() at all, since the above behavior is the default.", is_local=false, line=0, name="bind", params={{name="fd", param_type="number"}, {name="ip", param_type="number"}, {name="port", param_type="number"}}, returns={{return_type="boolean"}}, signature="(fd: number, ip?: number, port?: number): boolean"}, {description=" Returns list of network adapter addresses.", is_local=false, line=0, name="siocgifconf", params={}, returns={{return_type="any"}}, signature="(): any"}, {description=" Tunes networking parameters.\n `level` and `optname` may be one of the following pairs. The ellipses\n type signature above changes depending on which options are used.\n `optname` is the option feature magic number. The constants for\n these will be set to `0` if the option isn't supported on the host\n platform.\n Raises `ENOPROTOOPT` if your `level` / `optname` combination isn't\n valid, recognized, or supported on the host platform.\n Raises `ENOTSOCK` if `fd` is valid but isn't a socket.\n Raises `EBADF` if `fd` isn't valid.\n unix.getsockopt(fd:int, level:int, optname:int)\n  value:int\n  nil, unix.Errno\n unix.setsockopt(fd:int, level:int, optname:int, value:bool)\n  true\n  nil, unix.Errno\n - `SOL_SOCKET`, `SO_TYPE`\n - `SOL_SOCKET`, `SO_DEBUG`\n - `SOL_SOCKET`, `SO_ACCEPTCONN`\n - `SOL_SOCKET`, `SO_BROADCAST`\n - `SOL_SOCKET`, `SO_REUSEADDR`\n - `SOL_SOCKET`, `SO_REUSEPORT`\n - `SOL_SOCKET`, `SO_KEEPALIVE`\n - `SOL_SOCKET`, `SO_DONTROUTE`\n - `SOL_TCP`, `TCP_NODELAY`\n - `SOL_TCP`, `TCP_CORK`\n - `SOL_TCP`, `TCP_QUICKACK`\n - `SOL_TCP`, `TCP_FASTOPEN_CONNECT`\n - `SOL_TCP`, `TCP_DEFER_ACCEPT`\n - `SOL_IP`, `IP_HDRINCL`\n unix.getsockopt(fd:int, level:int, optname:int)\n  value:int\n  nil, unix.Errno\n unix.setsockopt(fd:int, level:int, optname:int, value:int)\n  true\n  nil, unix.Errno\n - `SOL_SOCKET`, `SO_SNDBUF`\n - `SOL_SOCKET`, `SO_RCVBUF`\n - `SOL_SOCKET`, `SO_RCVLOWAT`\n - `SOL_SOCKET`, `SO_SNDLOWAT`\n - `SOL_TCP`, `TCP_KEEPIDLE`\n - `SOL_TCP`, `TCP_KEEPINTVL`\n - `SOL_TCP`, `TCP_FASTOPEN`\n - `SOL_TCP`, `TCP_KEEPCNT`\n - `SOL_TCP`, `TCP_MAXSEG`\n - `SOL_TCP`, `TCP_SYNCNT`\n - `SOL_TCP`, `TCP_NOTSENT_LOWAT`\n - `SOL_TCP`, `TCP_WINDOW_CLAMP`\n - `SOL_IP`, `IP_TOS`\n - `SOL_IP`, `IP_MTU`\n - `SOL_IP`, `IP_TTL`\n unix.getsockopt(fd:int, level:int, optname:int)\n  secs:int, nsecs:int\n  nil, unix.Errno\n unix.setsockopt(fd:int, level:int, optname:int, secs:int[, nanos:int])\n  true\n  nil, unix.Errno\n - `SOL_SOCKET`, `SO_RCVTIMEO`: If this option is specified then\n your stream socket will have a read() / recv() timeout. If the\n specified interval elapses without receiving data, then EAGAIN\n shall be returned by read. If this option is used on listening\n sockets, it'll be inherited by accepted sockets. Your redbean\n already does this for GetClientFd() based on the `-t` flag.\n - `SOL_SOCKET`, `SO_SNDTIMEO`: This is the same as `SO_RCVTIMEO`\n but it applies to the write() / send() functions.\n unix.getsockopt(fd:int, unix.SOL_SOCKET, unix.SO_LINGER)\n  seconds:int, enabled:bool\n  nil, unix.Errno\n unix.setsockopt(fd:int, unix.SOL_SOCKET, unix.SO_LINGER, secs:int, enabled:bool)\n  true\n  nil, unix.Errno\n This `SO_LINGER` parameter can be used to make close() a blocking\n call. Normally when the kernel returns immediately when it receives\n close(). Sometimes it's desirable to have extra assurance on errors\n happened, even if it comes at the cost of performance.\n unix.setsockopt(serverfd:int, unix.SOL_TCP, unix.TCP_SAVE_SYN, enabled:int)\n  true\n  nil, unix.Errno\n unix.getsockopt(clientfd:int, unix.SOL_TCP, unix.TCP_SAVED_SYN)\n  syn_packet_bytes:str\n  nil, unix.Errno\n This `TCP_SAVED_SYN` option may be used to retrieve the bytes of the\n TCP SYN packet that the client sent when the connection for `fd` was\n opened. In order for this to work, `TCP_SAVE_SYN` must have been set\n earlier on the listening socket. This is Linux-only. You can use the\n `OnServerListen` hook to enable SYN saving in your Redbean. When the\n `TCP_SAVE_SYN` option isn't used, this may return empty string.", is_local=false, line=0, name="getsockopt", params={{name="fd", param_type="number"}, {name="level", param_type="number"}, {name="optname", param_type="number"}}, returns={{return_type="number"}}, signature="(fd: number, level: number, optname: number): number"}, {description=" Tunes networking parameters.\n `level` and `optname` may be one of the following pairs. The ellipses\n type signature above changes depending on which options are used.\n `optname` is the option feature magic number. The constants for\n these will be set to `0` if the option isn't supported on the host\n platform.\n Raises `ENOPROTOOPT` if your `level` / `optname` combination isn't\n valid, recognized, or supported on the host platform.\n Raises `ENOTSOCK` if `fd` is valid but isn't a socket.\n Raises `EBADF` if `fd` isn't valid.\n unix.getsockopt(fd:int, level:int, optname:int)\n  value:int\n  nil, unix.Errno\n unix.setsockopt(fd:int, level:int, optname:int, value:bool)\n  true\n  nil, unix.Errno\n - `SOL_SOCKET`, `SO_TYPE`\n - `SOL_SOCKET`, `SO_DEBUG`\n - `SOL_SOCKET`, `SO_ACCEPTCONN`\n - `SOL_SOCKET`, `SO_BROADCAST`\n - `SOL_SOCKET`, `SO_REUSEADDR`\n - `SOL_SOCKET`, `SO_REUSEPORT`\n - `SOL_SOCKET`, `SO_KEEPALIVE`\n - `SOL_SOCKET`, `SO_DONTROUTE`\n - `SOL_TCP`, `TCP_NODELAY`\n - `SOL_TCP`, `TCP_CORK`\n - `SOL_TCP`, `TCP_QUICKACK`\n - `SOL_TCP`, `TCP_FASTOPEN_CONNECT`\n - `SOL_TCP`, `TCP_DEFER_ACCEPT`\n - `SOL_IP`, `IP_HDRINCL`\n unix.getsockopt(fd:int, level:int, optname:int)\n  value:int\n  nil, unix.Errno\n unix.setsockopt(fd:int, level:int, optname:int, value:int)\n  true\n  nil, unix.Errno\n - `SOL_SOCKET`, `SO_SNDBUF`\n - `SOL_SOCKET`, `SO_RCVBUF`\n - `SOL_SOCKET`, `SO_RCVLOWAT`\n - `SOL_SOCKET`, `SO_SNDLOWAT`\n - `SOL_TCP`, `TCP_KEEPIDLE`\n - `SOL_TCP`, `TCP_KEEPINTVL`\n - `SOL_TCP`, `TCP_FASTOPEN`\n - `SOL_TCP`, `TCP_KEEPCNT`\n - `SOL_TCP`, `TCP_MAXSEG`\n - `SOL_TCP`, `TCP_SYNCNT`\n - `SOL_TCP`, `TCP_NOTSENT_LOWAT`\n - `SOL_TCP`, `TCP_WINDOW_CLAMP`\n - `SOL_IP`, `IP_TOS`\n - `SOL_IP`, `IP_MTU`\n - `SOL_IP`, `IP_TTL`\n unix.getsockopt(fd:int, level:int, optname:int)\n  secs:int, nsecs:int\n  nil, unix.Errno\n unix.setsockopt(fd:int, level:int, optname:int, secs:int[, nanos:int])\n  true\n  nil, unix.Errno\n - `SOL_SOCKET`, `SO_RCVTIMEO`: If this option is specified then\n your stream socket will have a read() / recv() timeout. If the\n specified interval elapses without receiving data, then EAGAIN\n shall be returned by read. If this option is used on listening\n sockets, it'll be inherited by accepted sockets. Your redbean\n already does this for GetClientFd() based on the `-t` flag.\n - `SOL_SOCKET`, `SO_SNDTIMEO`: This is the same as `SO_RCVTIMEO`\n but it applies to the write() / send() functions.\n unix.getsockopt(fd:int, unix.SOL_SOCKET, unix.SO_LINGER)\n  seconds:int, enabled:bool\n  nil, unix.Errno\n unix.setsockopt(fd:int, unix.SOL_SOCKET, unix.SO_LINGER, secs:int, enabled:bool)\n  true\n  nil, unix.Errno\n This `SO_LINGER` parameter can be used to make close() a blocking\n call. Normally when the kernel returns immediately when it receives\n close(). Sometimes it's desirable to have extra assurance on errors\n happened, even if it comes at the cost of performance.\n unix.setsockopt(serverfd:int, unix.SOL_TCP, unix.TCP_SAVE_SYN, enabled:int)\n  true\n  nil, unix.Errno\n unix.getsockopt(clientfd:int, unix.SOL_TCP, unix.TCP_SAVED_SYN)\n  syn_packet_bytes:str\n  nil, unix.Errno\n This `TCP_SAVED_SYN` option may be used to retrieve the bytes of the\n TCP SYN packet that the client sent when the connection for `fd` was\n opened. In order for this to work, `TCP_SAVE_SYN` must have been set\n earlier on the listening socket. This is Linux-only. You can use the\n `OnServerListen` hook to enable SYN saving in your Redbean. When the\n `TCP_SAVE_SYN` option isn't used, this may return empty string.", is_local=false, line=0, name="setsockopt", params={{name="fd", param_type="number"}, {name="level", param_type="number"}, {name="optname", param_type="number"}, {name="value", param_type="boolean | number"}}, returns={{return_type="boolean"}}, signature="(fd: number, level: number, optname: number, value: boolean | number): boolean"}, {description=" Checks for events on a set of file descriptors.\n The table of file descriptors to poll uses sparse integer keys. Any\n pairs with non-integer keys will be ignored. Pairs with negative\n keys are ignored by poll(). The returned table will be a subset of\n the supplied file descriptors.\n `events` and `revents` may be any combination (using bitwise OR) of:\n - `POLLIN` (events, revents): There is data to read.\n - `POLLOUT` (events, revents): Writing is now possible, although may\n still block if available space in a socket or pipe is exceeded\n (unless `O_NONBLOCK` is set).\n - `POLLPRI` (events, revents): There is some exceptional condition\n (for example, out-of-band data on a TCP socket).\n - `POLLRDHUP` (events, revents): Stream socket peer closed\n connection, or shut down writing half of connection.\n - `POLLERR` (revents): Some error condition.\n - `POLLHUP` (revents): Hang up. When reading from a channel such as\n a pipe or a stream socket, this event merely indicates that the\n peer closed its end of the channel.\n - `POLLNVAL` (revents): Invalid request.\n If this is set to -1 then that means block as long as it takes until there's an\n event or an interrupt. If the timeout expires, an empty table is returned.", is_local=false, line=0, name="poll", params={{name="fds", param_type="{number:number}"}, {name="timeoutms", param_type="number"}}, returns={{return_type="{number:number}"}}, signature="(fds: {number:number}, timeoutms?: number): {number:number}"}, {description=" Returns hostname of system.", is_local=false, line=0, name="gethostname", params={}, returns={{return_type="string"}}, signature="(): string"}, {description=" Begins listening for incoming connections on a socket.", is_local=false, line=0, name="listen", params={{name="fd", param_type="number"}, {name="backlog", param_type="number"}}, returns={{return_type="boolean"}}, signature="(fd: number, backlog?: number): boolean"}, {description=" Accepts new client socket descriptor for a listening tcp socket.\n `flags` may have any combination (using bitwise OR) of:\n - `SOCK_CLOEXEC`\n - `SOCK_NONBLOCK`", is_local=false, line=0, name="accept", params={{name="serverfd", param_type="number"}, {name="flags", param_type="number"}}, returns={{return_type="number"}, {return_type="number"}, {return_type="number"}}, signature="(serverfd: number, flags?: number): number, number, number"}, {description=" Connects a TCP socket to a remote host.\n With TCP this is a blocking operation. For a UDP socket it simply\n remembers the intended address so that `send()` or `write()` may be used\n rather than `sendto()`.", is_local=false, line=0, name="connect", params={{name="fd", param_type="number"}, {name="ip", param_type="number"}, {name="port", param_type="number"}}, returns={{return_type="boolean"}}, signature="(fd: number, ip: number, port: number): boolean"}, {description=" Retrieves the local address of a socket.", is_local=false, line=0, name="getsockname", params={{name="fd", param_type="number"}}, returns={{return_type="number"}, {return_type="number"}}, signature="(fd: number): number, number"}, {description=" Retrieves the remote address of a socket.\n This operation will either fail on `AF_UNIX` sockets or return an\n empty string.", is_local=false, line=0, name="getpeername", params={{name="fd", param_type="number"}}, returns={{return_type="number"}, {return_type="number"}}, signature="(fd: number): number, number"}, {description=" - `MSG_WAITALL`\n - `MSG_DONTROUTE`\n - `MSG_PEEK`\n - `MSG_OOB`", is_local=false, line=0, name="recv", params={{name="fd", param_type="number"}, {name="bufsiz", param_type="number"}, {name="flags", param_type="number"}}, returns={{return_type="string"}}, signature="(fd: number, bufsiz?: number, flags?: number): string"}, {description=" - `MSG_WAITALL`\n - `MSG_DONTROUTE`\n - `MSG_PEEK`\n - `MSG_OOB`", is_local=false, line=0, name="recvfrom", params={{name="fd", param_type="number"}, {name="bufsiz", param_type="number"}, {name="flags", param_type="number"}}, returns={{return_type="string"}, {return_type="number"}, {return_type="number"}}, signature="(fd: number, bufsiz?: number, flags?: number): string, number, number"}, {description=" This is the same as `write` except it has a `flags` argument\n that's intended for sockets.\n - `MSG_NOSIGNAL`: Don't SIGPIPE on EOF\n - `MSG_OOB`: Send stream data through out of bound channel\n - `MSG_DONTROUTE`: Don't go through gateway (for diagnostics)\n - `MSG_MORE`: Manual corking to belay nodelay (0 on non-Linux)", is_local=false, line=0, name="send", params={{name="fd", param_type="number"}, {name="data", param_type="string"}, {name="flags", param_type="number"}}, returns={{return_type="number"}}, signature="(fd: number, data: string, flags?: number): number"}, {description=" This is useful for sending messages over UDP sockets to specific\n addresses.\n - `MSG_OOB`\n - `MSG_DONTROUTE`\n - `MSG_NOSIGNAL`", is_local=false, line=0, name="sendto", params={{name="fd", param_type="number"}, {name="data", param_type="string"}, {name="ip", param_type="number"}, {name="port", param_type="number"}, {name="flags", param_type="number"}}, returns={{return_type="number"}}, signature="(fd: number, data: string, ip: number, port: number, flags?: number): number"}, {description=" Partially closes socket.\n - `SHUT_RD`: sends a tcp half close for reading\n - `SHUT_WR`: sends a tcp half close for writing\n - `SHUT_RDWR`\n This system call currently has issues on Macintosh, so portable code\n should log rather than assert failures reported by `shutdown()`.", is_local=false, line=0, name="shutdown", params={{name="fd", param_type="number"}, {name="how", param_type="number"}}, returns={{return_type="boolean"}}, signature="(fd: number, how: number): boolean"}, {description=" Manipulates bitset of signals blocked by process.\n - `SIG_BLOCK`: applies `mask` to set of blocked signals using bitwise OR\n - `SIG_UNBLOCK`: removes bits in `mask` from set of blocked signals\n - `SIG_SETMASK`: replaces process signal mask with `mask`\n `mask` is a unix.Sigset() object (see section below).\n For example, to temporarily block `SIGTERM` and `SIGINT` so critical\n work won't be interrupted, sigprocmask() can be used as follows:\n newmask = unix.Sigset(unix.SIGTERM)\n oldmask = assert(unix.sigprocmask(unix.SIG_BLOCK, newmask))\n -- do something...\n assert(unix.sigprocmask(unix.SIG_SETMASK, oldmask))", is_local=false, line=0, name="sigprocmask", params={{name="how", param_type="number"}, {name="newmask", param_type="Sigset"}}, returns={{return_type="Sigset"}}, signature="(how: number, newmask: Sigset): Sigset"}, {description=" - `unix.SIGINT`\n - `unix.SIGQUIT`\n - `unix.SIGTERM`\n - etc.\n - Lua function\n - `unix.SIG_IGN`\n - `unix.SIG_DFL`\n - `unix.SA_RESTART`: Enables BSD signal handling semantics. Normally\n i/o entrypoints check for pending signals to deliver. If one gets\n delivered during an i/o call, the normal behavior is to cancel the\n i/o operation and return -1 with `EINTR` in errno. If you use the\n `SA_RESTART` flag then that behavior changes, so that any function\n that's been annotated with @restartable will not return `EINTR`\n and will instead resume the i/o operation. This makes coding\n easier but it can be an anti-pattern if not used carefully, since\n poor usage can easily result in latency issues. It also requires\n one to do more work in signal handlers, so special care needs to\n be given to which C library functions are @asyncsignalsafe.\n - `unix.SA_RESETHAND`: Causes signal handler to be single-shot. This\n means that, upon entry of delivery to a signal handler, it's reset\n to the `SIG_DFL` handler automatically. You may use the alias\n `SA_ONESHOT` for this flag, which means the same thing.\n - `unix.SA_NODEFER`: Disables the reentrancy safety check on your signal\n handler. Normally that's a good thing, since for instance if your\n `SIGSEGV` signal handler happens to segfault, you're going to want\n your process to just crash rather than looping endlessly. But in\n some cases it's desirable to use `SA_NODEFER` instead, such as at\n times when you wish to `longjmp()` out of your signal handler and\n back into your program. This is only safe to do across platforms\n for non-crashing signals such as `SIGCHLD` and `SIGINT`. Crash\n handlers should use Xed instead to recover execution, because on\n Windows a `SIGSEGV` or `SIGTRAP` crash handler might happen on a\n separate stack and/or a separate thread. You may use the alias\n `SA_NOMASK` for this flag, which means the same thing.\n - `unix.SA_NOCLDWAIT`: Changes `SIGCHLD` so the zombie is gone and\n you can't call wait() anymore; similar but may still deliver the\n SIGCHLD.\n - `unix.SA_NOCLDSTOP`: Lets you set `SIGCHLD` handler that's only\n notified on exit/termination and not notified on `SIGSTOP`,\n `SIGTSTP`, `SIGTTIN`, `SIGTTOU`, or `SIGCONT`.\n Example:\n function OnSigUsr1(sig)\n gotsigusr1 = true\n end\n gotsigusr1 = false\n oldmask = assert(unix.sigprocmask(unix.SIG_BLOCK, unix.Sigset(unix.SIGUSR1)))\n assert(unix.sigaction(unix.SIGUSR1, OnSigUsr1))\n assert(unix.raise(unix.SIGUSR1))\n assert(not gotsigusr1)\n ok, err = unix.sigsuspend(oldmask)\n assert(not ok)\n assert(err:errno() == unix.EINTR)\n assert(gotsigusr1)\n assert(unix.sigprocmask(unix.SIG_SETMASK, oldmask))\n It's a good idea to not do too much work in a signal handler.", is_local=false, line=0, name="sigaction", params={{name="sig", param_type="number"}, {name="handler", param_type="function | number"}, {name="flags", param_type="number"}, {name="mask", param_type="Sigset"}}, returns={{return_type="function | number"}, {return_type="number"}, {return_type="Sigset"}}, signature="(sig: number, handler?: function | number, flags?: number, mask?: Sigset): function | number, number, Sigset"}, {description=" Waits for signal to be delivered.\n The signal mask is temporarily replaced with `mask` during this system call.", is_local=false, line=0, name="sigsuspend", params={{name="mask", param_type="Sigset"}}, returns={{return_type="nil"}, {return_type="Errno"}}, signature="(mask?: Sigset): nil, Errno"}, {description=" Causes `SIGALRM` signals to be generated at some point(s) in the\n future. The `which` parameter should be `ITIMER_REAL`.\n Here's an example of how to create a 400 ms interval timer:\n ticks = 0\n assert(unix.sigaction(unix.SIGALRM, function(sig)\n print('tick no. %d' % {ticks})\n ticks = ticks + 1\n end))\n assert(unix.setitimer(unix.ITIMER_REAL, 0, 400e6, 0, 400e6))\n while true do\n unix.sigsuspend()\n end\n Here's how you'd do a single-shot timeout in 1 second:\n unix.sigaction(unix.SIGALRM, MyOnSigAlrm, unix.SA_RESETHAND)\n unix.setitimer(unix.ITIMER_REAL, 0, 0, 1, 0)", is_local=false, line=0, name="setitimer", params={{name="which", param_type="number"}, {name="intervalsec", param_type="number"}, {name="intervalns", param_type="number"}, {name="valuesec", param_type="number"}, {name="valuens", param_type="number"}}, returns={{return_type="number"}, {return_type="number"}, {return_type="number"}, {return_type="number"}}, signature="(which: number, intervalsec: number, intervalns: number, valuesec: number, valuens: number): number, number, number, number"}, {description=" Turns platform-specific `sig` code into its symbolic name.\n For example:\n >: unix.strsignal(9)\n \"SIGKILL\"\n >: unix.strsignal(unix.SIGKILL)\n \"SIGKILL\"\n Please note that signal numbers are normally different across\n supported platforms, and the constants should be preferred.", is_local=false, line=0, name="strsignal", params={{name="sig", param_type="number"}}, returns={{return_type="string"}}, signature="(sig: number): string"}, {description=" Changes resource limit.\n - `RLIMIT_AS` limits the size of the virtual address space. This\n will work on all platforms. It's emulated on XNU and Windows which\n means it won't propagate across execve() currently.\n - `RLIMIT_CPU` causes `SIGXCPU` to be sent to the process when the\n soft limit on CPU time is exceeded, and the process is destroyed\n when the hard limit is exceeded. It works everywhere but Windows\n where it should be possible to poll getrusage() with setitimer().\n - `RLIMIT_FSIZE` causes `SIGXFSZ` to sent to the process when the\n soft limit on file size is exceeded and the process is destroyed\n when the hard limit is exceeded. It works everywhere but Windows.\n - `RLIMIT_NPROC` limits the number of simultaneous processes and it\n should work on all platforms except Windows. Please be advised it\n limits the process, with respect to the activities of the user id\n as a whole.\n - `RLIMIT_NOFILE` limits the number of open file descriptors and it\n should work on all platforms except Windows (TODO).\n If a limit isn't supported by the host platform, it'll be set to\n 127. On most platforms these limits are enforced by the kernel and\n as such are inherited by subprocesses.", is_local=false, line=0, name="setrlimit", params={{name="resource", param_type="number"}, {name="soft", param_type="number"}, {name="hard", param_type="number"}}, returns={{return_type="boolean"}}, signature="(resource: number, soft: number, hard?: number): boolean"}, {description=" Returns information about resource limits for current process.", is_local=false, line=0, name="getrlimit", params={{name="resource", param_type="number"}}, returns={{return_type="number"}, {return_type="number"}}, signature="(resource: number): number, number"}, {description=" Adjusts the nice value (scheduling priority) of the calling process.\n The nice value ranges from -20 (highest priority) to 19 (lowest priority).\n Only privileged processes can lower the nice value (increase priority).\n `inc` is added to the current nice value. Positive values decrease\n priority, negative values increase it.\n Returns the new nice value on success. Note that -1 is a valid return\n value, so errors must be detected by checking the second return value.", is_local=false, line=0, name="nice", params={{name="inc", param_type="number"}}, returns={{return_type="number"}}, signature="(inc: number): number"}, {description=" Gets the scheduling priority of a process, process group, or user.\n `which` specifies what `who` refers to:\n - `PRIO_PROCESS`: `who` is a process id (0 = calling process)\n - `PRIO_PGRP`: `who` is a process group id (0 = calling process group)\n - `PRIO_USER`: `who` is a user id (0 = calling user)\n Returns the priority value (nice value) which ranges from -20 to 19.\n Note that -1 is a valid return value, so errors must be detected by\n checking the second return value.", is_local=false, line=0, name="getpriority", params={{name="which", param_type="number"}, {name="who", param_type="number"}}, returns={{return_type="number"}}, signature="(which: number, who: number): number"}, {description=" Sets the scheduling priority of a process, process group, or user.\n `which` specifies what `who` refers to:\n - `PRIO_PROCESS`: `who` is a process id (0 = calling process)\n - `PRIO_PGRP`: `who` is a process group id (0 = calling process group)\n - `PRIO_USER`: `who` is a user id (0 = calling user)\n `prio` is the new priority value (nice value), ranging from -20\n (highest priority) to 19 (lowest priority). Only privileged processes\n can set negative priority values.", is_local=false, line=0, name="setpriority", params={{name="which", param_type="number"}, {name="who", param_type="number"}, {name="prio", param_type="number"}}, returns={{return_type="boolean"}}, signature="(which: number, who: number, prio: number): boolean"}, {description=" Returns information about resource usage for current process, e.g.\n >: unix.getrusage()\n {utime={0, 53644000}, maxrss=44896, minflt=545, oublock=24, nvcsw=9}\n - `RUSAGE_SELF`: current process\n - `RUSAGE_THREAD`: current thread\n - `RUSAGE_CHILDREN`: not supported on Windows NT\n - `RUSAGE_BOTH`: not supported on non-Linux", is_local=false, line=0, name="getrusage", params={{name="who", param_type="number"}}, returns={{return_type="Rusage"}}, signature="(who?: number): Rusage"}, {description=" Restrict system operations.\n This can be used to sandbox your redbean workers. It allows finer\n customization compared to the `-S` flag.\n Pledging causes most system calls to become unavailable. On Linux the\n disabled calls will return EPERM whereas OpenBSD kills the process.\n Using pledge is irreversible. On Linux it causes PR_SET_NO_NEW_PRIVS\n to be set on your process.\n By default exit and exit_group are always allowed. This is useful\n for processes that perform pure computation and interface with the\n parent via shared memory.\n Once pledge is in effect, the chmod functions (if allowed) will not\n permit the sticky/setuid/setgid bits to change. Linux will EPERM here\n and OpenBSD should ignore those three bits rather than crashing.\n User and group IDs also can't be changed once pledge is in effect.\n OpenBSD should ignore the chown functions without crashing. Linux\n will just EPERM.\n Memory functions won't permit creating executable code after pledge.\n Restrictions on origin of SYSCALL instructions will become enforced\n on Linux (cf. msyscall) after pledge too, which means the process\n gets killed if SYSCALL is used outside the .privileged section. One\n exception is if the \"exec\" group is specified, in which case these\n restrictions need to be loosened.\n This list has been curated to focus on the\n system calls for which this module provides wrappers. See the\n Cosmopolitan Libc pledge() documentation for a comprehensive and\n authoritative list of raw system calls. Having the raw system call\n list may be useful if you're executing foreign programs.\n ### stdio\n Allows read, write, send, recv, recvfrom, close, clock_getres,\n clock_gettime, dup, fchdir, fstat, fsync, fdatasync, ftruncate,\n getdents, getegid, getrandom, geteuid, getgid, getgroups,\n getitimer, getpgid, getpgrp, getpid, hgetppid, getresgid,\n getresuid, getrlimit, getsid, gettimeofday, getuid, lseek,\n madvise, brk, mmap/mprotect (PROT_EXEC isn't allowed), msync,\n munmap, gethostname, nanosleep, pipe, pipe2, poll, setitimer,\n shutdown, sigaction, sigsuspend, sigprocmask, socketpair, umask,\n wait4, getrusage, ioctl(FIONREAD), ioctl(FIONBIO), ioctl(FIOCLEX),\n ioctl(FIONCLEX), fcntl(F_GETFD), fcntl(F_SETFD), fcntl(F_GETFL),\n fcntl(F_SETFL).\n ### rpath\n Allows chdir, getcwd, open, stat, fstat, access, readlink, chmod,\n chmod, fchmod.\n ### wpath\n Allows getcwd, open, stat, fstat, access, readlink, chmod, fchmod.\n ### cpath\n Allows rename, link, symlink, unlink, mkdir, rmdir.\n ### fattr\n Allows chmod, fchmod, utimensat, futimens.\n ### flock\n Allows flock, fcntl(F_GETLK), fcntl(F_SETLK), fcntl(F_SETLKW).\n ### tty\n Allows isatty, tiocgwinsz, tcgets, tcsets, tcsetsw, tcsetsf.\n ### inet\n Allows socket (AF_INET), listen, bind, connect, accept,\n getpeername, getsockname, setsockopt, getsockopt.\n ### unix\n Allows socket (AF_UNIX), listen, bind, connect, accept,\n getpeername, getsockname, setsockopt, getsockopt.\n ### dns\n Allows sendto, recvfrom, socket(AF_INET), connect.\n ### recvfd\n Allows recvmsg, recvmmsg.\n ### sendfd\n Allows sendmsg, sendmmsg.\n ### proc\n Allows fork, vfork, clone, kill, tgkill, getpriority, setpriority,\n setrlimit, setpgid, setsid.\n ### id\n Allows setuid, setreuid, setresuid, setgid, setregid, setresgid,\n setgroups, setrlimit, getpriority, setpriority.\n ### settime\n Allows settimeofday and clock_adjtime.\n ### unveil\n Allows unveil().\n ### exec\n Allows execve.\n If the executable in question needs a loader, then you will need\n \"rpath prot_exec\" too. With APE, security is strongest when you\n assimilate your binaries beforehand, using the --assimilate flag,\n or the o//tool/build/assimilate program. On OpenBSD this is\n mandatory.\n ### prot_exec\n Allows mmap(PROT_EXEC) and mprotect(PROT_EXEC).\n This may be needed to launch non-static non-native executables,\n such as non-assimilated APE binaries, or programs that link\n dynamic shared objects, i.e. most Linux distro binaries.\n In that case, this specifies the promises that'll apply once `execve()`\n happens. If this is `NULL` then the default is used, which is\n unrestricted. OpenBSD allows child processes to escape the sandbox\n (so a pledged OpenSSH server process can do things like spawn a root\n shell). Linux however requires monotonically decreasing privileges.\n This function will will perform some validation on Linux to make\n sure that `execpromises` is a subset of `promises`. Your libc\n wrapper for `execve()` will then apply its SECCOMP BPF filter later.\n Since Linux has to do this before calling `sys_execve()`, the executed\n process will be weakened to have execute permissions too.\n - `unix.PLEDGE_PENALTY_KILL_THREAD` causes the violating thread to\n be killed. This is the default on Linux. It's effectively the\n same as killing the process, since redbean has no threads. The\n termination signal can't be caught and will be either `SIGSYS`\n or `SIGABRT`. Consider enabling stderr logging below so you'll\n know why your program failed. Otherwise check the system log.\n - `unix.PLEDGE_PENALTY_KILL_PROCESS` causes the process and all\n its threads to be killed. This is always the case on OpenBSD.\n - `unix.PLEDGE_PENALTY_RETURN_EPERM` causes system calls to just\n return an `EPERM` error instead of killing. This is a gentler\n solution that allows code to display a friendly warning. Please\n note this may lead to weird behaviors if the software being\n sandboxed is lazy about checking error results.\n `mode` may optionally bitwise or the following flags:\n - `unix.PLEDGE_STDERR_LOGGING` enables friendly error message\n logging letting you know which promises are needed whenever\n violations occur. Without this, violations will be logged to\n `dmesg` on Linux if the penalty is to kill the process. You\n would then need to manually look up the system call number and\n then cross reference it with the cosmopolitan libc pledge()\n documentation. You can also use `strace -ff` which is easier.\n This is ignored OpenBSD, which already has a good system log.\n Turning on stderr logging (which uses SECCOMP trapping) also\n means that the `unix.WTERMSIG()` on your killed processes will\n always be `unix.SIGABRT` on both Linux and OpenBSD. Otherwise,\n Linux prefers to raise `unix.SIGSYS`.", is_local=false, line=0, name="pledge", params={{name="promises", param_type="string"}, {name="execpromises", param_type="string"}, {name="mode", param_type="number"}}, returns={{return_type="boolean"}}, signature="(promises?: string, execpromises?: string, mode?: number): boolean"}, {description=" Restricts filesystem operations, e.g.\n unix.unveil(\".\", \"r\");     -- current dir + children visible\n unix.unveil(\"/etc\", \"r\");  -- make /etc readable too\n unix.unveil(nil, nil);     -- commit and lock policy\n Unveiling restricts a thread's view of the filesystem to a set of\n allowed paths with specific privileges.\n Once you start using unveil(), the entire file system is considered\n hidden. You then specify, by repeatedly calling unveil(), which paths\n should become unhidden. When you're finished, you call `unveil(nil,nil)`\n which commits your policy, after which further use is forbidden, in\n the current thread, as well as any threads or processes it spawns.\n There are some differences between unveil() on Linux versus OpenBSD.\n 1. Build your policy and lock it in one go. On OpenBSD, policies take\n effect immediately and may evolve as you continue to call unveil()\n but only in a more restrictive direction. On Linux, nothing will\n happen until you call `unveil(nil,nil)` which commits and locks.\n 2. Try not to overlap directory trees. On OpenBSD, if directory trees\n overlap, then the most restrictive policy will be used for a given\n file. On Linux overlapping may result in a less restrictive policy\n and possibly even undefined behavior.\n 3. OpenBSD and Linux disagree on error codes. On OpenBSD, accessing\n paths outside of the allowed set raises ENOENT, and accessing ones\n with incorrect permissions raises EACCES. On Linux, both these\n cases raise EACCES.\n 4. Unlike OpenBSD, Linux does nothing to conceal the existence of\n paths. Even with an unveil() policy in place, it's still possible\n to access the metadata of all files using functions like stat()\n and open(O_PATH), provided you know the path. A sandboxed process\n can always, for example, determine how many bytes of data are in\n /etc/passwd, even if the file isn't readable. But it's still not\n possible to use opendir() and go fishing for paths which weren't\n previously known.\n This system call is supported natively on OpenBSD and polyfilled on\n Linux using the Landlock LSM[1].\n - `r` makes `path` available for read-only path operations,\n corresponding to the pledge promise \"rpath\".\n - `w` makes `path` available for write operations, corresponding\n to the pledge promise \"wpath\".\n - `x` makes `path` available for execute operations,\n corresponding to the pledge promises \"exec\" and \"execnative\".\n - `c` allows `path` to be created and removed, corresponding to\n the pledge promise \"cpath\".", is_local=false, line=0, name="unveil", params={{name="path", param_type="string"}, {name="permissions", param_type="string"}}, returns={{return_type="boolean"}}, signature="(path: string, permissions: string): boolean"}, {description=" Breaks down UNIX timestamp into Zulu Time numbers.", is_local=false, line=0, name="gmtime", params={{name="unixts", param_type="number"}}, returns={{return_type="number"}, {return_type="number"}, {return_type="number"}, {return_type="number"}, {return_type="number"}, {return_type="number"}, {return_type="number"}, {return_type="number"}, {return_type="number"}, {return_type="number"}, {return_type="string"}}, signature="(unixts: number): number, number, number, number, number, number, number, number, number, number, string"}, {description=" Breaks down UNIX timestamp into local time numbers, e.g.\n >: unix.localtime(unix.clock_gettime())\n 2022    4       28      2       14      22      -25200  4       117     1       \"PDT\"\n This follows the same API as `gmtime()` which has further details.\n Your redbean ships with a subset of the time zone database.\n - `/zip/usr/share/zoneinfo/Honolulu`   Z-10\n - `/zip/usr/share/zoneinfo/Anchorage`  Z -9\n - `/zip/usr/share/zoneinfo/GST`        Z -8\n - `/zip/usr/share/zoneinfo/Boulder`    Z -6\n - `/zip/usr/share/zoneinfo/Chicago`    Z -5\n - `/zip/usr/share/zoneinfo/New_York`   Z -4\n - `/zip/usr/share/zoneinfo/UTC`        Z +0\n - `/zip/usr/share/zoneinfo/GMT`        Z +0\n - `/zip/usr/share/zoneinfo/London`     Z +1\n - `/zip/usr/share/zoneinfo/Berlin`     Z +2\n - `/zip/usr/share/zoneinfo/Israel`     Z +3\n - `/zip/usr/share/zoneinfo/India`      Z +5\n - `/zip/usr/share/zoneinfo/Beijing`    Z +8\n - `/zip/usr/share/zoneinfo/Japan`      Z +9\n - `/zip/usr/share/zoneinfo/Sydney`     Z+10\n You can control which timezone is used using the `TZ` environment\n variable. If your time zone isn't included in the above list, you\n can simply copy it inside your redbean. The same is also the case\n for future updates to the database, which can be swapped out when\n needed, without having to recompile.", is_local=false, line=0, name="localtime", params={{name="unixts", param_type="number"}}, returns={{return_type="number"}, {return_type="number"}, {return_type="number"}, {return_type="number"}, {return_type="number"}, {return_type="number"}, {return_type="number"}, {return_type="number"}, {return_type="number"}, {return_type="number"}, {return_type="string"}}, signature="(unixts: number): number, number, number, number, number, number, number, number, number, number, string"}, {description=" Gets information about file or directory.\n - `AT_SYMLINK_NOFOLLOW`: do not follow symbolic links.", is_local=false, line=0, name="stat", params={{name="path", param_type="string"}, {name="flags", param_type="number"}, {name="dirfd", param_type="number"}}, returns={{return_type="Stat"}}, signature="(path: string, flags?: number, dirfd?: number): Stat"}, {description=" Tests if file mode represents a directory.", is_local=false, line=0, name="S_ISDIR", params={{name="mode", param_type="number"}}, returns={{return_type="boolean"}}, signature="(mode: number): boolean"}, {description=" Tests if file mode represents a regular file.", is_local=false, line=0, name="S_ISREG", params={{name="mode", param_type="number"}}, returns={{return_type="boolean"}}, signature="(mode: number): boolean"}, {description=" Tests if file mode represents a symbolic link.", is_local=false, line=0, name="S_ISLNK", params={{name="mode", param_type="number"}}, returns={{return_type="boolean"}}, signature="(mode: number): boolean"}, {description=" Tests if file mode represents a block device.", is_local=false, line=0, name="S_ISBLK", params={{name="mode", param_type="number"}}, returns={{return_type="boolean"}}, signature="(mode: number): boolean"}, {description=" Tests if file mode represents a character device.", is_local=false, line=0, name="S_ISCHR", params={{name="mode", param_type="number"}}, returns={{return_type="boolean"}}, signature="(mode: number): boolean"}, {description=" Tests if file mode represents a FIFO/pipe.", is_local=false, line=0, name="S_ISFIFO", params={{name="mode", param_type="number"}}, returns={{return_type="boolean"}}, signature="(mode: number): boolean"}, {description=" Tests if file mode represents a socket.", is_local=false, line=0, name="S_ISSOCK", params={{name="mode", param_type="number"}}, returns={{return_type="boolean"}}, signature="(mode: number): boolean"}, {description=" Gets information about opened file descriptor.\n `flags` may have any of:\n - `AT_SYMLINK_NOFOLLOW`: do not follow symbolic links.\n `dirfd` defaults to to `unix.AT_FDCWD` and may optionally be set to\n a directory file descriptor to which `path` is relative.\n A common use for `fstat()` is getting the size of a file. For example:\n fd = assert(unix.open(\"hello.txt\", unix.O_RDONLY))\n st = assert(unix.fstat(fd))\n Log(kLogInfo, 'hello.txt is %d bytes in size' % {st:size()})\n unix.close(fd)", is_local=false, line=0, name="fstat", params={{name="fd", param_type="number"}}, returns={{return_type="Stat"}}, signature="(fd: number): Stat"}, {description=" Opens directory for listing its contents.\n For example, to print a simple directory listing:\n Write('<ul>\\r\\n')\n for name, kind, ino, off in assert(unix.opendir(dir)) do\n if name ~= '.' and name ~= '..' then\n Write('<li>%s\\r\\n' % {EscapeHtml(name)})\n end\n end\n Write('</ul>\\r\\n')", is_local=false, line=0, name="opendir", params={{name="path", param_type="string"}}, returns={{return_type="Dir"}}, signature="(path: string): Dir"}, {description=" Opens directory for listing its contents, via an fd.\n The returned `unix.Dir` takes ownership of the file descriptor\n and will close it automatically when garbage collected.", is_local=false, line=0, name="fdopendir", params={{description="should be created by `open(path, O_RDONLY|O_DIRECTORY)`.", name="fd", param_type="integer"}}, returns={{return_type="function"}, {return_type="Dir"}}, signature="(fd?: any): function, Dir"}, {description=" Returns true if file descriptor is a teletypewriter. Otherwise nil\n with an Errno object holding one of the following values:\n - `ENOTTY` if `fd` is valid but not a teletypewriter\n - `EBADF` if `fd` isn't a valid file descriptor.\n - `EPERM` if pledge() is used without `tty` in lenient mode\n No other error numbers are possible.", is_local=false, line=0, name="isatty", params={{name="fd", param_type="number"}}, returns={{return_type="boolean"}}, signature="(fd: number): boolean"}, {is_local=false, line=0, name="tiocgwinsz", params={{name="fd", param_type="number"}}, returns={{return_type="number"}, {return_type="number"}}, signature="(fd: number): number, number"}, {description=" Returns file descriptor of open anonymous file.\n This creates a secure temporary file inside `$TMPDIR`. If it isn't\n defined, then `/tmp` is used on UNIX and GetTempPath() is used on\n the New Technology. This resolution of `$TMPDIR` happens once.\n Once close() is called, the returned file is guaranteed to be\n deleted automatically. On UNIX the file is unlink()'d before this\n function returns. On the New Technology it happens upon close().\n On the New Technology, temporary files created by this function\n should have better performance, because `kNtFileAttributeTemporary`\n asks the kernel to more aggressively cache and reduce i/o ops.", is_local=false, line=0, name="tmpfd", params={}, returns={{return_type="number"}}, signature="(): number"}, {description=" Relinquishes scheduled quantum.", is_local=false, line=0, name="sched_yield", params={}, returns={}, signature="()"}, {description=" Creates interprocess shared memory mapping.\n This function allocates special memory that'll be inherited across\n fork in a shared way. By default all memory in Redbean is \"private\"\n memory that's only viewable and editable to the process that owns\n it. When unix.fork() happens, memory is copied appropriately so\n that changes to memory made in the child process, don't clobber\n the memory at those same addresses in the parent process. If you\n don't want that to happen, and you want the memory to be shared\n similar to how it would be shared if you were using threads, then\n you can use this function to achieve just that.\n The memory object this function returns may be accessed using its\n methods, which support atomics and futexes. It's very low-level.\n For example, you can use it to implement scalable mutexes:\n mem = unix.mapshared(8000 * 8)\n LOCK = 0 -- pick an arbitrary word index for lock\n -- From Futexes Are Tricky Version 1.1  Mutex, Take 3;\n -- Ulrich Drepper, Red Hat Incorporated, June 27, 2004.\n function Lock()\n local ok, old = mem:cmpxchg(LOCK, 0, 1)\n if not ok then\n if old == 1 then\n old = mem:xchg(LOCK, 2)\n end\n while old > 0 do\n mem:wait(LOCK, 2)\n old = mem:xchg(LOCK, 2)\n end\n end\n end\n function Unlock()\n old = mem:add(LOCK, -1)\n if old == 2 then\n mem:store(LOCK, 0)\n mem:wake(LOCK, 1)\n end\n end\n It's possible to accomplish the same thing as unix.mapshared()\n using files and unix.fcntl() advisory locks. However this goes\n significantly faster. For example, that's what SQLite does and\n we recommend using SQLite for IPC in redbean. But, if your app\n has thousands of forked processes fighting for a file lock you\n might need something lower level than file locks, to implement\n things like throttling. Shared memory is a good way to do that\n since there's nothing that's faster.\n The `size` parameter needs to be a multiple of 8. The returned\n memory is zero initialized. When allocating shared memory, you\n should try to get as much use out of it as possible, since the\n overhead of allocating a single shared mapping is 500 words of\n resident memory and 8000 words of virtual memory. It's because\n the Cosmopolitan Libc mmap() granularity is 2**16.\n This system call does not fail. An exception is instead thrown\n if sufficient memory isn't available.", is_local=false, line=0, name="mapshared", params={{name="size", param_type="number"}}, returns={{return_type="Memory"}}, signature="(size: number): Memory"}, {description=" Signal set for blocking, unblocking, and waiting on signals.\n Used with `unix.sigprocmask()`, `unix.sigaction()`, and `unix.sigsuspend()`.\n The unix.Sigset class defines a mutable bitset that may currently\n contain 128 entries. See `unix.NSIG` to find out how many signals\n your operating system actually supports.\n Constructs new signal bitset object.", is_local=false, line=0, name="Sigset", params={{name="sig", param_type="number"}, {name="...", param_type="number"}}, returns={{return_type="Sigset"}}, signature="(sig: number, ...: number): Sigset"}}, module_doc="Type declarations for the `unix` module.", records={{description=" Shared memory for inter-process communication.\n Provides atomic operations and wait/wake primitives for synchronization.\n unix.Memory encapsulates memory that's shared across fork() and\n this module provides the fundamental synchronization primitives.\n Redbean memory maps may be used in two ways:\n 1. as an array of bytes a.k.a. a string\n 2. as an array of words a.k.a. integers\n They're aliased, union, or overlapped views of the same memory.\n For example if you write a string to your memory region, you'll\n be able to read it back as an integer.\n Reads, writes, and word operations will throw an exception if a\n memory boundary error or overflow occurs.", fields={{"read", "function(self: Memory, offset?: number, bytes?: number): string", " The starting byte index from which memory is copied, which defaults to zero.\n If `bytes` is none or nil, then the nul-terminated string at\n `offset` is returned. You may specify `bytes` to safely read\n binary data.\n This operation happens atomically. Each shared mapping has a\n single lock which is used to synchronize reads and writes to\n that specific map. To make it scale, create additional maps."}, {"write", "function(self: Memory, data: string, offset?: number, bytes?: number)", " Writes bytes to memory region.\n `offset` is the starting byte index to which memory is copied,\n which defaults to zero.\n If `bytes` is none or nil, then an implicit nil-terminator\n will be included after your `data` so things like json can\n be easily serialized to shared memory.\n This operation happens atomically. Each shared mapping has a\n single lock which is used to synchronize reads and writes to\n that specific map. To make it scale, create additional maps."}, {"load", "function(self: Memory, word_index: number): number", " Loads word from memory region.\n This operation is atomic and has relaxed barrier semantics."}, {"store", "function(self: Memory, word_index: number, value: number)", " Stores word from memory region.\n This operation is atomic and has relaxed barrier semantics."}, {"xchg", "function(self: Memory, word_index: number, value: number): number", " Exchanges value.\n This sets word at `word_index` to `value` and returns the value\n previously held in by the word.\n This operation is atomic and provides the same memory barrier\n semantics as the aligned x86 LOCK XCHG instruction."}, {"cmpxchg", "function(self: Memory, word_index: number, old: number, new: number): boolean, number", " Compares and exchanges value.\n This inspects the word at `word_index` and if its value is the same\n as `old` then it'll be replaced by the value `new`, in which case\n `true, old` shall be returned. If a different value was held at\n word, then `false` shall be returned along with the word.\n This operation happens atomically and provides the same memory\n barrier semantics as the aligned x86 LOCK CMPXCHG instruction."}, {"fetch_add", "function(self: Memory, word_index: number, value: number): number", " Fetches then adds value.\n This method modifies the word at `word_index` to contain the sum of\n value and the `value` paremeter. This method then returns the value\n as it existed before the addition was performed.\n This operation is atomic and provides the same memory barrier\n semantics as the aligned x86 LOCK XADD instruction."}, {"fetch_and", "function(self: Memory, word_index: number, value: number): number", " Fetches and bitwise ands value.\n This operation happens atomically and provides the same memory\n barrier ordering semantics as its x86 implementation."}, {"fetch_or", "function(self: Memory, word_index: number, value: number): number", " Fetches and bitwise ors value.\n This operation happens atomically and provides the same memory\n barrier ordering semantics as its x86 implementation."}, {"fetch_xor", "function(self: Memory, word_index: number, value: number): number", " Fetches and bitwise xors value.\n This operation happens atomically and provides the same memory\n barrier ordering semantics as its x86 implementation."}, {"wait", "function(self: Memory, word_index: number, expect: number, abs_deadline?: number, nanos?: number): number", " Waits for word to have a different value.\n This method asks the kernel to suspend the process until either the\n absolute deadline expires or we're woken up by another process that\n calls `unix.Memory:wake()`.\n The `expect` parameter is used only upon entry to synchronize the\n transition to kernelspace. The kernel doesn't actually poll the\n memory location. It uses `expect` to make sure the process doesn't\n get added to the wait list unless it's sure that it needs to wait,\n since the kernel can only control the ordering of wait / wake calls\n across processes.\n The default behavior is to wait until the heat death of the universe\n if necessary. You may alternatively specify an absolute deadline. If\n it's less than or equal to the value returned by clock_gettime, then\n this routine is non-blocking. Otherwise we'll block at most until\n the current time reaches the absolute deadline.\n Futexes are currently supported on Linux, FreeBSD, OpenBSD. On other\n platforms this method calls sched_yield() and will either (1) return\n unix.EINTR if a deadline is specified, otherwise (2) 0 is returned.\n This means futexes will *work* on Windows, Mac, and NetBSD but they\n won't be scalable in terms of CPU usage when many processes wait on\n one process that holds a lock for a long time. In the future we may\n polyfill futexes in userspace for these platforms to improve things\n for folks who've adopted this api. If lock scalability is something\n you need on Windows and MacOS today, then consider fcntl() which is\n well-supported on all supported platforms but requires using files.\n Please test your use case though, because it's kind of an edge case\n to have the scenario above, and chances are this op will work fine.\n `EINTR` if a signal is delivered while waiting on deadline. Callers\n should use futexes inside a loop that is able to cope with spurious\n wakeups. We don't actually guarantee the value at word has in fact\n changed when this returns.\n `EAGAIN` is raised if, upon entry, the word at `word_index` had a\n different value than what's specified at `expect`.\n `ETIMEDOUT` is raised when the absolute deadline expires."}, {"wake", "function(self: Memory, index: number, count?: number): number", " Wakes other processes waiting on word.\n This method may be used to signal or broadcast to waiters. The\n `count` specifies the number of processes that should be woken,\n which defaults to `INT_MAX`.\n The return value is the number of processes that were actually woken\n as a result of the system call. No failure conditions are defined."}}, line=0, name="Memory"}, {description=" Directory handle for reading directory entries.\n `unix.Dir` objects are created by `opendir()` or `fdopendir()`.", fields={{"close", "function(self: Dir): boolean", " Closes directory stream object and associated its file descriptor.\n This is called automatically by the garbage collector.\n This may be called multiple times."}, {"read", "function(self: Dir): string, number, number, number", " Reads entry from directory stream.\n Returns `nil` if there are no more entries.\n On error, `nil` will be returned and `errno` will be non-nil.\n `kind` can be any of:\n - `DT_REG`: file is a regular file\n - `DT_DIR`: file is a directory\n - `DT_BLK`: file is a block device\n - `DT_LNK`: file is a symbolic link\n - `DT_CHR`: file is a character device\n - `DT_FIFO`: file is a named pipe\n - `DT_SOCK`: file is a named socket\n - `DT_UNKNOWN`\n Note: This function also serves as the `__call` metamethod, so that\n `unix.Dir` objects may be used as a for loop iterator."}, {"fd", "function(self: Dir): number", " Returns `EOPNOTSUPP` if using a `/zip/...` path or if using Windows NT."}, {"tell", "function(self: Dir): number", ""}, {"rewind", "function(self: Dir)", " Resets stream back to beginning."}}, line=0, name="Dir"}, {description=" Process resource usage statistics.\n Contains CPU time, memory usage, I/O, and context switch counters.\n `unix.Rusage` objects are created by `wait()` or `getrusage()`.", fields={{"utime", "function(self: Rusage): number, number", " It's always the case that `0  nanos < 1e9`.\n On Windows NT this is collected from GetProcessTimes()."}, {"stime", "function(self: Rusage): number, number", " It's always the case that `0  nanos < 1e9`.\n On Windows NT this is collected from GetProcessTimes()."}, {"maxrss", "function(self: Rusage): number", " On Windows NT this is collected from\n `NtProcessMemoryCountersEx::PeakWorkingSetSize / 1024`."}, {"idrss", "function(self: Rusage): number", " If you chart memory usage over the lifetime of your process, then\n this would be the space filled in beneath the chart. The frequency\n of kernel scheduling is defined as `unix.CLK_TCK`.  Each time a tick\n happens, the kernel samples your process's memory usage, by adding\n it to this value. You can derive the average consumption from this\n value by computing how many ticks are in `utime + stime`.\n Currently only available on FreeBSD and NetBSD."}, {"ixrss", "function(self: Rusage): number", " If you chart memory usage over the lifetime of your process, then\n this would be the space filled in beneath the chart. The frequency\n of kernel scheduling is defined as unix.CLK_TCK.  Each time a tick\n happens, the kernel samples your process's memory usage, by adding\n it to this value. You can derive the average consumption from this\n value by computing how many ticks are in `utime + stime`.\n Currently only available on FreeBSD and NetBSD."}, {"isrss", "function(self: Rusage): number", " If you chart memory usage over the lifetime of your process, then\n this would be the space filled in beneath the chart. The frequency\n of kernel scheduling is defined as `unix.CLK_TCK`. Each time a tick\n happens, the kernel samples your process's memory usage, by adding\n it to this value. You can derive the average consumption from this\n value by computing how many ticks are in `utime + stime`.\n This is only applicable to redbean if its built with MODE=tiny,\n because redbean likes to allocate its own deterministic stack.\n Currently only available on FreeBSD and NetBSD."}, {"minflt", "function(self: Rusage): number", " This number indicates how many times redbean was preempted by the\n kernel to `memcpy()` a 4096-byte page. This is one of the tradeoffs\n `fork()` entails. This number is usually tinier, when your binaries\n are tinier.\n Not available on Windows NT."}, {"majflt", "function(self: Rusage): number", " Returns number of major page faults.\n This number indicates how many times redbean was preempted by the\n kernel to perform i/o. For example, you might have used `mmap()` to\n load a large file into memory lazily.\n On Windows NT this is `NtProcessMemoryCountersEx::PageFaultCount`."}, {"nswap", "function(self: Rusage): number", " Operating systems like to reserve hard disk space to back their RAM\n guarantees, like using a gold standard for fiat currency. When your\n system is under heavy memory load, swap operations may happen while\n redbean is working. This number keeps track of them.\n Not available on Linux, Windows NT."}, {"inblock", "function(self: Rusage): number", " On Windows NT this is `NtIoCounters::ReadOperationCount`."}, {"oublock", "function(self: Rusage): number", " On Windows NT this is `NtIoCounters::WriteOperationCount`."}, {"msgsnd", "function(self: Rusage): number", " Not available on Linux, Windows NT."}, {"msgrcv", "function(self: Rusage): number", " Not available on Linux, Windows NT."}, {"nsignals", "function(self: Rusage): number", " Not available on Linux."}, {"nvcsw", "function(self: Rusage): number", " This number is a good thing. It means your redbean finished its work\n quickly enough within a time slice that it was able to give back the\n remaining time to the system."}, {"nivcsw", "function(self: Rusage)", " This number is a bad thing. It means your redbean was preempted by a\n higher priority process after failing to finish its work, within the\n allotted time slice."}}, line=0, name="Rusage"}, {description=" File metadata and attributes.\n Contains file size, permissions, ownership, and timestamps.\n `unix.Stat` objects are created by `stat()` or `fstat()`.\n Use `unix.S_ISDIR()`, `unix.S_ISREG()`, etc. to check file type from mode.", fields={{"size", "function(self: Stat): number", ""}, {"mode", "function(self: Stat): number", " Contains file type and permissions.\n For example, `0010644` is what you might see for a file and\n `0040755` is what you might see for a directory.\n To determine the file type:\n - `unix.S_ISREG(st:mode())` means regular file\n - `unix.S_ISDIR(st:mode())` means directory\n - `unix.S_ISLNK(st:mode())` means symbolic link\n - `unix.S_ISCHR(st:mode())` means character device\n - `unix.S_ISBLK(st:mode())` means block device\n - `unix.S_ISFIFO(st:mode())` means fifo or pipe\n - `unix.S_ISSOCK(st:mode())` means socket"}, {"uid", "function(self: Stat): number", ""}, {"gid", "function(self: Stat): number", ""}, {"birthtim", "function(self: Stat): number, number", " File birth time.\n This field should be accurate on Apple, Windows, and BSDs. On Linux\n this is the minimum of atim/mtim/ctim. On Windows NT nanos is only\n accurate to hectonanoseconds.\n Here's an example of how you might print a file timestamp:\n st = assert(unix.stat('/etc/passwd'))\n unixts, nanos = st:birthtim()\n year,mon,mday,hour,min,sec,gmtoffsec = unix.localtime(unixts)\n Write('%.4d-%.2d-%.2dT%.2d:%.2d:%.2d.%.9d%+.2d%.2d % {\n year, mon, mday, hour, min, sec, nanos,\n gmtoffsec / (60 * 60), math.abs(gmtoffsec) % 60})"}, {"mtim", "function(self: Stat): number, number", ""}, {"atim", "function(self: Stat): number, number", " Please note that file systems are sometimes mounted with `noatime`\n out of concern for i/o performance. Linux also provides `O_NOATIME`\n as an option for open().\n On Windows NT this is the same as birth time."}, {"ctim", "function(self: Stat): number, number", " Means time file status was last changed on UNIX.\n On Windows NT this is the same as birth time."}, {"blocks", "function(self: Stat): number", " This provides some indication of how much physical storage a file\n actually consumes. For example, for small file systems, your system\n might report this number as being 8, which means 4096 bytes."}, {"blksize", "function(self: Stat): number", " This field might be of assistance in computing optimal i/o sizes.\n Please note this field has no relationship to blocks, as the latter\n is fixed at a 512 byte size."}, {"ino", "function(self: Stat): number", " This can be used to detect some other process used `rename()` to swap\n out a file underneath you, so you can do a refresh. redbean does it\n during each main process heartbeat for its own use cases.\n On Windows NT this is set to `NtByHandleFileInformation::FileIndex`."}, {"dev", "function(self: Stat): number", " On Windows NT this is set to `NtByHandleFileInformation::VolumeSerialNumber`."}, {"rdev", "function(self: Stat): number", " This value may be set to `0` or `-1` for files that aren't devices,\n depending on the operating system. `unix.major()` and `unix.minor()`\n may be used to extract the device numbers."}, {"nlink", "function(self: Stat): any", ""}, {"gen", "function(self: Stat): any", ""}, {"flags", "function(self: Stat): any", ""}}, line=0, name="Stat"}, {fields={{"add", "function(self: Sigset, sig: number)", " Adds signal to bitset."}, {"remove", "function(self: Sigset, sig: number)", " Removes signal from bitset."}, {"fill", "function(self: Sigset)", " Sets all bits in signal bitset to `true`."}, {"clear", "function(self: Sigset)", " Sets all bits in signal bitset to `false`."}, {"contains", "function(self: Sigset, sig: number): boolean", ""}, {"__repr", "function(self: Sigset): string", ""}, {"__tostring", "function(self: Sigset): string", ""}}, line=0, name="Sigset"}, {description=" Error information from system calls.\n Provides detailed error codes and human-readable descriptions.\n This object is returned by system calls that fail. We prefer returning\n an object because for many system calls, an error is part of their normal\n operation. For example, it's often desirable to use the `errno()` method\n when performing a `read()` to check for EINTR.", fields={{"errno", "function(self: Errno): number", " The error number is always different for different platforms. On\n UNIX systems, error numbers occupy the range [1,127] in practice.\n The System V ABI reserves numbers as high as 4095. On Windows NT,\n error numbers can go up to 65535."}, {"winerr", "function(self: Errno): number", " On UNIX systems this is always 0. On Windows NT this will normally\n be the same as `errno(). Because Windows defines so many error codes,\n there's oftentimes a multimapping between its error codes and System\n Five. In those cases, this value reflects the `GetLastError()` result\n at the time the error occurred."}, {"name", "function(self: Errno): string", " For example, this might return `\"EINTR\"`."}, {"call", "function(self: Errno): string", " For example, this might return `\"read\"` if `read()` was what failed."}, {"doc", "function(self: Errno): string", " For example, this might return `\"Interrupted system call\"`."}, {"__tostring", "function(self: Errno): string", " Different information components are delimited by slash.\n For example, this might return `\"EINTR/4/Interrupted system call\"`.\n On Windows NT this will include additional information about the\n Windows error (including FormatMessage() output) if the WIN32 error\n differs from the System Five error code."}}, line=0, name="Errno"}, {description="Constants defined in the unix module.", fields={{"AF_INET", "number", ""}, {"AF_UNIX", "number", ""}, {"AF_UNSPEC", "number", ""}, {"ARG_MAX", "number", ""}, {"AT_EACCES", "number", ""}, {"AT_FDCWD", "number", ""}, {"AT_SYMLINK_NOFOLLOW", "number", ""}, {"BUFSIZ", "number", ""}, {"CLK_TCK", "number", ""}, {"CLOCK_REALTIME", "number", ""}, {"CLOCK_MONOTONIC", "number", ""}, {"CLOCK_BOOTTIME", "number", ""}, {"CLOCK_MONOTONIC_RAW", "number", ""}, {"CLOCK_REALTIME_COARSE", "number", ""}, {"CLOCK_MONOTONIC_COARSE", "number", ""}, {"CLOCK_THREAD_CPUTIME_ID", "number", ""}, {"CLOCK_PROCESS_CPUTIME_ID", "number", ""}, {"DT_BLK", "number", ""}, {"DT_CHR", "number", ""}, {"DT_DIR", "number", ""}, {"DT_FIFO", "number", ""}, {"DT_LNK", "number", ""}, {"DT_REG", "number", ""}, {"DT_SOCK", "number", ""}, {"DT_UNKNOWN", "number", ""}, {"E2BIG", "number", ""}, {"EACCES", "number", ""}, {"EADDRINUSE", "number", ""}, {"EADDRNOTAVAIL", "number", ""}, {"EAFNOSUPPORT", "number", ""}, {"EAGAIN", "number", ""}, {"EALREADY", "number", ""}, {"EBADF", "number", ""}, {"EBADFD", "number", ""}, {"EBADMSG", "number", ""}, {"EBUSY", "number", ""}, {"ECANCELED", "number", ""}, {"ECHILD", "number", ""}, {"ECONNABORTED", "number", ""}, {"ECONNREFUSED", "number", ""}, {"ECONNRESET", "number", ""}, {"EDEADLK", "number", ""}, {"EDESTADDRREQ", "number", ""}, {"EDOM", "number", ""}, {"EDQUOT", "number", ""}, {"EEXIST", "number", ""}, {"EFAULT", "number", ""}, {"EFBIG", "number", ""}, {"EHOSTDOWN", "number", ""}, {"EHOSTUNREACH", "number", ""}, {"EIDRM", "number", ""}, {"EILSEQ", "number", ""}, {"EINPROGRESS", "number", ""}, {"EINTR", "number", ""}, {"EINVAL", "number", ""}, {"EIO", "number", ""}, {"EISCONN", "number", ""}, {"EISDIR", "number", ""}, {"ELOOP", "number", ""}, {"EMFILE", "number", ""}, {"EMLINK", "number", ""}, {"EMSGSIZE", "number", ""}, {"ENAMETOOLONG", "number", ""}, {"ENETDOWN", "number", ""}, {"ENETRESET", "number", ""}, {"ENETUNREACH", "number", ""}, {"ENFILE", "number", ""}, {"ENOBUFS", "number", ""}, {"ENODATA", "number", ""}, {"ENODEV", "number", ""}, {"ENOENT", "number", ""}, {"ENOEXEC", "number", ""}, {"ENOLCK", "number", ""}, {"ENOMEM", "number", ""}, {"ENOMSG", "number", ""}, {"ENONET", "number", ""}, {"ENOPROTOOPT", "number", ""}, {"ENOSPC", "number", ""}, {"ENOSYS", "number", ""}, {"ENOTBLK", "number", ""}, {"ENOTCONN", "number", ""}, {"ENOTDIR", "number", ""}, {"ENOTEMPTY", "number", ""}, {"ENOTRECOVERABLE", "number", ""}, {"ENOTSOCK", "number", ""}, {"ENOTSUP", "number", ""}, {"ENOTTY", "number", ""}, {"ENXIO", "number", ""}, {"EOPNOTSUPP", "number", ""}, {"EOVERFLOW", "number", ""}, {"EOWNERDEAD", "number", ""}, {"EPERM", "number", ""}, {"EPFNOSUPPORT", "number", ""}, {"EPIPE", "number", ""}, {"EPROTO", "number", ""}, {"EPROTONOSUPPORT", "number", ""}, {"EPROTOTYPE", "number", ""}, {"ERANGE", "number", ""}, {"EREMOTE", "number", ""}, {"ERESTART", "number", ""}, {"EROFS", "number", ""}, {"ESHUTDOWN", "number", ""}, {"ESOCKTNOSUPPORT", "number", ""}, {"ESPIPE", "number", ""}, {"ESRCH", "number", ""}, {"ESTALE", "number", ""}, {"ETIME", "number", ""}, {"ETIMEDOUT", "number", ""}, {"ETOOMANYREFS", "number", ""}, {"ETXTBSY", "number", ""}, {"EUSERS", "number", ""}, {"EXDEV", "number", ""}, {"FD_CLOEXEC", "number", ""}, {"F_GETFD", "number", ""}, {"F_GETFL", "number", ""}, {"F_OK", "number", ""}, {"F_RDLCK", "number", ""}, {"F_SETFD", "number", ""}, {"F_SETFL", "number", ""}, {"F_SETLK", "number", ""}, {"F_SETLKW", "number", ""}, {"F_UNLCK", "number", ""}, {"F_WRLCK", "number", ""}, {"IPPROTO_ICMP", "number", ""}, {"IPPROTO_IP", "number", ""}, {"IPPROTO_RAW", "number", ""}, {"IPPROTO_TCP", "number", ""}, {"IPPROTO_UDP", "number", ""}, {"IP_HDRINCL", "number", ""}, {"IP_MTU", "number", ""}, {"IP_TOS", "number", ""}, {"IP_TTL", "number", ""}, {"ITIMER_PROF", "number", ""}, {"ITIMER_REAL", "number", ""}, {"ITIMER_VIRTUAL", "number", ""}, {"LOG_ALERT", "number", ""}, {"LOG_CRIT", "number", ""}, {"LOG_DEBUG", "number", ""}, {"LOG_EMERG", "number", ""}, {"LOG_ERR", "number", ""}, {"LOG_INFO", "number", ""}, {"LOG_NOTICE", "number", ""}, {"LOG_WARNING", "number", ""}, {"MSG_DONTROUTE", "number", ""}, {"MSG_MORE", "number", ""}, {"MSG_NOSIGNAL", "number", ""}, {"MSG_OOB", "number", ""}, {"MSG_PEEK", "number", ""}, {"MSG_WAITALL", "number", ""}, {"NAME_MAX", "number", ""}, {"NSIG", "number", ""}, {"O_RDONLY", "number", ""}, {"O_WRONLY", "number", ""}, {"O_RDWR", "number", ""}, {"O_CREAT", "number", ""}, {"O_TRUNC", "number", ""}, {"O_CLOEXEC", "number", ""}, {"O_EXCL", "number", ""}, {"O_APPEND", "number", ""}, {"O_NONBLOCK", "number", ""}, {"O_DIRECT", "number", ""}, {"O_DIRECTORY", "number", ""}, {"O_TMPFILE", "number", ""}, {"O_NOFOLLOW", "number", ""}, {"O_UNLINK", "number", ""}, {"O_DSYNC", "number", ""}, {"O_RSYNC", "number", ""}, {"O_SYNC", "number", ""}, {"O_NOATIME", "number", ""}, {"O_ACCMODE", "number", ""}, {"O_EXEC", "number", ""}, {"O_NOCTTY", "number", ""}, {"PATH_MAX", "number", ""}, {"PLEDGE_PENALTY_KILL_THREAD", "number", ""}, {"PLEDGE_PENALTY_KILL_PROCESS", "number", ""}, {"PLEDGE_PENALTY_RETURN_EPERM", "number", ""}, {"PLEDGE_STDERR_LOGGING", "number", ""}, {"PIPE_BUF", "number", ""}, {"POLLERR", "number", ""}, {"POLLHUP", "number", ""}, {"POLLIN", "number", ""}, {"POLLNVAL", "number", ""}, {"POLLOUT", "number", ""}, {"POLLPRI", "number", ""}, {"POLLRDBAND", "number", ""}, {"POLLRDHUP", "number", ""}, {"POLLRDNORM", "number", ""}, {"POLLWRBAND", "number", ""}, {"POLLWRNORM", "number", ""}, {"RLIMIT_AS", "number", ""}, {"RLIMIT_CPU", "number", ""}, {"RLIMIT_FSIZE", "number", ""}, {"RLIMIT_NOFILE", "number", ""}, {"RLIMIT_NPROC", "number", ""}, {"RLIMIT_RSS", "number", ""}, {"PRIO_PROCESS", "number", ""}, {"PRIO_PGRP", "number", ""}, {"PRIO_USER", "number", ""}, {"RUSAGE_BOTH", "number", ""}, {"RUSAGE_CHILDREN", "number", ""}, {"RUSAGE_SELF", "number", ""}, {"RUSAGE_THREAD", "number", ""}, {"R_OK", "number", ""}, {"SA_NOCLDSTOP", "number", ""}, {"SA_NOCLDWAIT", "number", ""}, {"SA_NODEFER", "number", ""}, {"SA_RESETHAND", "number", ""}, {"SA_RESTART", "number", ""}, {"SEEK_CUR", "number", ""}, {"SEEK_END", "number", ""}, {"SEEK_SET", "number", ""}, {"SHUT_RD", "number", ""}, {"SHUT_WR", "number", ""}, {"SHUT_RDWR", "number", ""}, {"SIGABRT", "number", ""}, {"SIGALRM", "number", ""}, {"SIGBUS", "number", ""}, {"SIGCHLD", "number", ""}, {"SIGCONT", "number", ""}, {"SIGEMT", "number", ""}, {"SIGFPE", "number", ""}, {"SIGHUP", "number", ""}, {"SIGILL", "number", ""}, {"SIGINFO", "number", ""}, {"SIGINT", "number", ""}, {"SIGIO", "number", ""}, {"SIGKILL", "number", ""}, {"SIGPIPE", "number", ""}, {"SIGPROF", "number", ""}, {"SIGPWR", "number", ""}, {"SIGQUIT", "number", ""}, {"SIGRTMAX", "number", ""}, {"SIGRTMIN", "number", ""}, {"SIGSEGV", "number", ""}, {"SIGSTKFLT", "number", ""}, {"SIGSTOP", "number", ""}, {"SIGSYS", "number", ""}, {"SIGTERM", "number", ""}, {"SIGTRAP", "number", ""}, {"SIGTSTP", "number", ""}, {"SIGTTIN", "number", ""}, {"SIGTTOU", "number", ""}, {"SIGURG", "number", ""}, {"SIGUSR1", "number", ""}, {"SIGUSR2", "number", ""}, {"SIGVTALRM", "number", ""}, {"SIGWINCH", "number", ""}, {"SIGXCPU", "number", ""}, {"SIGXFSZ", "number", ""}, {"SIG_BLOCK", "number", ""}, {"SIG_DFL", "number", ""}, {"SIG_IGN", "number", ""}, {"SIG_SETMASK", "number", ""}, {"SIG_UNBLOCK", "number", ""}, {"SOCK_CLOEXEC", "number", ""}, {"SOCK_DGRAM", "number", ""}, {"SOCK_NONBLOCK", "number", ""}, {"SOCK_RAW", "number", ""}, {"SOCK_RDM", "number", ""}, {"SOCK_SEQPACKET", "number", ""}, {"SOCK_STREAM", "number", ""}, {"SOL_IP", "number", ""}, {"SOL_SOCKET", "number", ""}, {"SOL_TCP", "number", ""}, {"SOL_UDP", "number", ""}, {"SO_ACCEPTCONN", "number", ""}, {"SO_BROADCAST", "number", ""}, {"SO_DEBUG", "number", ""}, {"SO_DONTROUTE", "number", ""}, {"SO_ERROR", "number", ""}, {"SO_KEEPALIVE", "number", ""}, {"SO_LINGER", "number", ""}, {"SO_RCVBUF", "number", ""}, {"SO_RCVLOWAT", "number", ""}, {"SO_RCVTIMEO", "number", ""}, {"SO_REUSEADDR", "number", ""}, {"SO_REUSEPORT", "number", ""}, {"SO_SNDBUF", "number", ""}, {"SO_SNDLOWAT", "number", ""}, {"SO_SNDTIMEO", "number", ""}, {"SO_TYPE", "number", ""}, {"TCP_CORK", "number", ""}, {"TCP_DEFER_ACCEPT", "number", ""}, {"TCP_FASTOPEN", "number", ""}, {"TCP_FASTOPEN_CONNECT", "number", ""}, {"TCP_KEEPCNT", "number", ""}, {"TCP_KEEPIDLE", "number", ""}, {"TCP_KEEPINTVL", "number", ""}, {"TCP_MAXSEG", "number", ""}, {"TCP_NODELAY", "number", ""}, {"TCP_NOTSENT_LOWAT", "number", ""}, {"TCP_QUICKACK", "number", ""}, {"TCP_SAVED_SYN", "number", ""}, {"TCP_SAVE_SYN", "number", ""}, {"TCP_SYNCNT", "number", ""}, {"TCP_WINDOW_CLAMP", "number", ""}, {"UTIME_NOW", "number", ""}, {"UTIME_OMIT", "number", ""}, {"WNOHANG", "number", ""}, {"WUNTRACED", "number", ""}, {"WCONTINUED", "number", ""}, {"W_OK", "number", ""}, {"X_OK", "number", ""}}, line=0, name="unix Constants"}}}, ["cosmo.zip"]={examples={}, file="lib/types/cosmo/zip.d.tl", functions={{description=" Opens a ZIP archive for reading, writing, or appending.\n The first argument can be a file path string or a file descriptor integer.", is_local=false, line=0, name="open", params={{name="path", param_type="string | number"}, {name="mode", param_type="string"}, {name="options", param_type="OpenOptions"}}, returns={{return_type="any"}, {return_type="string | nil"}}, signature="(path: string | number, mode?: string, options?: OpenOptions): any, string | nil"}, {description=" Opens a ZIP archive from in-memory data for reading.", is_local=false, line=0, name="from", params={{name="data", param_type="string"}, {name="options", param_type="OpenOptions"}}, returns={{return_type="Reader | nil"}, {return_type="string | nil"}}, signature="(data: string, options?: OpenOptions): Reader | nil, string | nil"}}, module_doc="Type declarations for the `zip` module.", records={{fields={{"level", "number", " Compression level 0-9 (for \"w\" and \"a\" modes)"}, {"max_file_size", "number", " Maximum file size limit in bytes"}}, line=0, name="OpenOptions"}, {description=" File metadata within a ZIP archive.", fields={{"size", "number", " Uncompressed file size in bytes"}, {"compressed_size", "number", " Compressed file size in bytes"}, {"crc32", "number", " CRC32 checksum of uncompressed data"}, {"mtime", "number", " Modification time as Unix timestamp"}, {"method", "number", " Compression method (0=stored, 8=deflated)"}, {"mode", "number", " Unix file mode/permissions"}}, line=0, name="Stat"}, {fields={{"method", "string", " Compression method: `\"store\"` or `\"deflate\"`"}, {"mtime", "number", " Modification time as Unix timestamp"}, {"mode", "number", " Unix file mode (default 0644)"}}, line=0, name="AddOptions"}, {description=" Reader for extracting files from a ZIP archive.", fields={{"list", "function(self: Reader): {string}", " Lists all files in the ZIP archive."}, {"stat", "function(self: Reader, name: string): Stat | nil", " Gets metadata for a specific file in the archive."}, {"read", "function(self: Reader, name: string): string | nil, string | nil", " Reads the contents of a file from the archive."}, {"close", "function(self: Reader)", " Closes the ZIP reader and releases resources."}}, line=0, name="Reader"}, {description=" Writer for creating new ZIP archives.", fields={{"add", "function(self: Writer, name: string, content: string, options?: AddOptions): boolean | nil, string | nil", " Adds a file to the ZIP archive."}, {"close", "function(self: Writer)", " Closes the ZIP archive and writes the central directory."}}, line=0, name="Writer"}, {description=" Writer for appending files to an existing ZIP archive.", fields={{"add", "function(self: Appender, name: string, content: string, options?: AddOptions): boolean | nil, string | nil", " Adds a file to the ZIP archive."}, {"close", "function(self: Appender)", " Closes the ZIP archive and writes the updated central directory."}}, line=0, name="Appender"}}}}}