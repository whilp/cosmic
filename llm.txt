# cosmic-lua

> A single-file, self-contained Lua interpreter built on Cosmopolitan Libc

## Overview

cosmic-lua is a portable Lua 5.4 interpreter with Teal type checking that runs on Linux, macOS, Windows, FreeBSD, OpenBSD, and NetBSD as a single executable with no dependencies. It includes HTTP client, process spawning, file operations, and a full Teal compiler for statically-typed Lua development.

**Key Features:**
- Single Actually Portable Executable (APE) format
- Lua 5.4 with Teal type system integration
- Built-in HTTP client with retry logic
- Process spawning with pipe management
- Directory tree walking utilities
- SQLite support via lsqlite3
- ~6MB single file, no installation required

**Project Repository:** https://github.com/cosmopolitan-lang/cosmic

## Quick Start

Download the cosmic-lua binary and make it executable:

```bash
# Download latest release
curl -Lo cosmic https://github.com/cosmopolitan-lang/cosmic/releases/latest/download/cosmic-lua
chmod +x cosmic

# Run Lua code
./cosmic -e "print('Hello from cosmic-lua')"

# Run a script
./cosmic myscript.lua

# Type check Teal code
./cosmic --check mycode.tl

# Compile Teal to Lua
./cosmic --compile mycode.tl > mycode.lua
```

## Architecture

cosmic-lua consists of three main layers:

1. **cosmo**: Base Cosmopolitan Lua APIs (Fetch, Slurp, Barf, Sha256, etc.)
2. **cosmic**: Higher-level typed utilities (spawn, fetch, walk, teal)
3. **cosmic CLI**: Command-line interface with Teal integration

The binary embeds all libraries, type definitions, and the Teal compiler in a ZIP archive appended to the executable.

## Core API Reference

### cosmo - Base Cosmopolitan APIs

The cosmo module provides low-level system APIs:

```lua
local cosmo = require("cosmo")
```

#### HTTP Client

```lua
cosmo.Fetch(url: string, opts?: table): number, {string:string}, string
```

Fetches HTTP resource. Returns status code, headers table, and response body. On error, returns nil, error message string, and nil.

Parameters:
- url: HTTP/HTTPS URL to fetch
- opts: Optional configuration table
  - headers: {string:string} - Request headers
  - maxresponse: number - Max response size in bytes

Returns:
- status: HTTP status code (200, 404, etc.) or nil on error
- headers: Response headers table or error message string
- body: Response body string

Example:
```lua
local status, headers, body = cosmo.Fetch("https://api.github.com/users/octocat")
if not status then
  error("Fetch failed: " .. tostring(headers))
end
print("Status:", status)
for k, v in pairs(headers) do
  print(k .. ":", v)
end
print(body)
```

#### File I/O

```lua
cosmo.Slurp(path: string): string
```

Reads entire file into string. Throws error if file doesn't exist or can't be read.

```lua
cosmo.Barf(path: string, data: string, mode?: number): boolean
```

Writes string to file atomically. Creates parent directories if needed. Optional mode sets permissions (default 0644).

Example:
```lua
local content = cosmo.Slurp("input.txt")
local modified = content:gsub("foo", "bar")
cosmo.Barf("output.txt", modified, 0755)
```

#### Hashing & Encoding

```lua
cosmo.Sha256(data: string): string
```

Returns hex-encoded SHA256 hash of data.

```lua
cosmo.EncodeHex(data: string): string
cosmo.EncodeJson(value: any): string
cosmo.DecodeJson(json: string): any
cosmo.EncodeLua(value: any, opts?: table): string
```

Encoding and decoding utilities.

#### System Information

```lua
cosmo.GetHostOs(): string  -- "linux", "darwin", "windows", "freebsd", "openbsd", "netbsd"
cosmo.GetHostIsa(): string -- "x86_64", "aarch64", etc.
cosmo.GetRandomBytes(count: number): string
```

#### Script Detection

```lua
cosmo.is_main(): boolean
```

Returns true if current script is the main entry point (not a required module).

### cosmo.unix - Unix System Calls

```lua
local unix = require("cosmo.unix")
```

Provides direct access to Unix system calls with typed interfaces.

#### Process Control

```lua
unix.fork(): number
```

Forks current process. Returns 0 in child, child PID in parent.

```lua
unix.execve(path: string, argv: {string}, env: {string})
unix.execvpe(cmd: string, argv: {string}, env: {string})
```

Replace current process with new program. execvpe searches PATH.

```lua
unix.wait(pid?: number): number, number
```

Waits for child process. Returns PID and status.

```lua
unix.WIFEXITED(status: number): boolean
unix.WEXITSTATUS(status: number): number
```

Check if process exited normally and get exit code.

```lua
unix.kill(pid: number, signal: number): boolean
unix.getpid(): number
```

Send signal to process or get current PID.

#### File Descriptor Operations

```lua
unix.pipe(): number, number
```

Creates pipe. Returns read FD and write FD.

```lua
unix.dup(fd: number, newfd?: number): number
```

Duplicates file descriptor. If newfd specified, duplicates to that FD.

```lua
unix.open(path: string, flags: number, mode?: number): number, string
unix.close(fd: number): boolean
unix.read(fd: number, size: number): string
unix.write(fd: number, data: string): number
```

Low-level file operations.

Constants: unix.O_RDONLY, unix.O_WRONLY, unix.O_RDWR, unix.O_CREAT, unix.O_TRUNC, unix.O_APPEND

#### Directory Operations

```lua
unix.opendir(path: string): DirHandle
```

Opens directory for reading. Returns handle with :read() and :close() methods.

```lua
unix.mkdir(path: string, mode: number): boolean
unix.makedirs(path: string, mode?: number): boolean, string
unix.mkdtemp(template: string): string
unix.rmrf(path: string): boolean
unix.unlink(path: string): boolean
unix.rename(src: string, dst: string): boolean
```

Directory and file manipulation.

```lua
unix.stat(path: string, flags?: number): Stat
```

Gets file metadata. Returns object with :mode(), :size(), :mtim() methods.

```lua
unix.S_ISDIR(mode: number): boolean
unix.S_ISREG(mode: number): boolean
unix.S_ISLNK(mode: number): boolean
```

File type checking functions.

#### Environment

```lua
unix.environ(): {string}
unix.setenv(name: string, value: string): boolean
unix.unsetenv(name: string): boolean
unix.commandv(cmd: string): string
```

Environment variable management. commandv resolves command in PATH.

### cosmic.spawn - Process Spawning

```lua
local spawn = require("cosmic.spawn")
```

High-level typed interface for spawning subprocesses with automatic pipe management.

#### Main Function

```lua
spawn(argv: {string}, opts?: SpawnOpts): SpawnHandle, string
```

Spawns subprocess. Resolves command via PATH if not absolute. Creates pipes for stdin/stdout/stderr unless file descriptors provided.

Parameters:
- argv: Command and arguments (argv[1] is the command name)
- opts: Optional configuration
  - stdin: string | number - Input data or file descriptor (default: create pipe)
  - stdout: number - Output file descriptor (default: create pipe)
  - stderr: number - Error file descriptor (default: create pipe)
  - env: {string} - Environment variables (default: inherit from parent)

Returns:
- handle: SpawnHandle with pid and pipe objects
- error: Error message string if spawn failed (e.g., "command not found: foo")

SpawnHandle type:
```lua
{
  pid: number,
  stdin: Pipe,   -- has :write(data), :read(size?), :close() methods
  stdout: Pipe,
  stderr: Pipe,
  wait: function(): number, string,
  read: function(size?: number): boolean | string, string, number
}
```

#### Usage Patterns

Basic command execution:
```lua
local spawn = require("cosmic.spawn")

local handle = spawn({"git", "status"})
local ok, output, exit_code = handle:read()
if not ok then
  error("Command failed with exit code: " .. exit_code)
end
print(output)
```

Passing input:
```lua
local handle = spawn({"grep", "error"}, {
  stdin = "line 1\nerror on line 2\nline 3\n"
})
local ok, output = handle:read()
print(output) -- "error on line 2\n"
```

Streaming output (don't capture):
```lua
-- Output goes directly to terminal
local handle = spawn({"npm", "install"}, {
  stdout = 1,  -- Inherit stdout
  stderr = 2   -- Inherit stderr
})
local exit_code = handle:wait()
```

Custom environment:
```lua
local handle = spawn({"env"}, {
  env = {"PATH=/usr/bin", "HOME=/tmp"}
})
local ok, output = handle:read()
```

Reading incrementally:
```lua
local handle = spawn({"tail", "-f", "logfile"})
while true do
  local chunk = handle.stdout:read(1024)
  if not chunk or chunk == "" then break end
  io.write(chunk)
  io.flush()
end
```

Error handling:
```lua
local handle, err = spawn({"nonexistent-command"})
if not handle then
  print("Spawn failed:", err) -- "command not found: nonexistent-command"
  return
end

local ok, output, exit_code = handle:read()
if not ok then
  print("Command failed with exit code:", exit_code)
end
```

### cosmic.fetch - HTTP Client with Retry

```lua
local fetch = require("cosmic.fetch")
```

Structured wrapper around cosmo.Fetch that preserves error messages and adds retry logic.

#### Main Function

```lua
fetch.Fetch(url: string, opts?: Opts): Result
```

Fetches HTTP resource with optional retry on failure.

Parameters:
- url: HTTP/HTTPS URL
- opts: Optional configuration
  - headers: {string:string} - Request headers
  - maxresponse: number - Max response size
  - max_attempts: number - Retry count (default: 1, no retry)
  - max_delay: number - Max delay between retries in seconds (default: 30)
  - should_retry: function(Result): boolean - Custom retry logic

Returns Result record:
```lua
{
  ok: boolean,         -- true if request succeeded
  status: number,      -- HTTP status code (200, 404, etc.)
  headers: {string:string}, -- Response headers
  body: string,        -- Response body
  error: string        -- Error message if ok is false
}
```

#### Usage Patterns

Basic fetch:
```lua
local fetch = require("cosmic.fetch")

local result = fetch.Fetch("https://api.github.com/users/octocat")
if not result.ok then
  error("Fetch failed: " .. result.error)
end

if result.status == 200 then
  print(result.body)
else
  print("HTTP error:", result.status)
end
```

With retry on network errors:
```lua
local result = fetch.Fetch("https://flaky-api.com/data", {
  max_attempts = 4,
  max_delay = 10  -- Cap exponential backoff at 10 seconds
})
-- Automatically retries on network errors with exponential backoff: 2s, 4s, 8s
```

Custom retry logic:
```lua
local result = fetch.Fetch("https://api.example.com/data", {
  max_attempts = 3,
  should_retry = function(r)
    -- Retry on 5xx server errors or network failures
    return not r.ok or r.status >= 500
  end
})
```

With custom headers:
```lua
local result = fetch.Fetch("https://api.example.com/data", {
  headers = {
    ["Authorization"] = "Bearer " .. token,
    ["Accept"] = "application/json"
  }
})
```

Processing JSON response:
```lua
local cosmo = require("cosmo")
local fetch = require("cosmic.fetch")

local result = fetch.Fetch("https://api.github.com/users/octocat")
if result.ok and result.status == 200 then
  local data = cosmo.DecodeJson(result.body)
  print("Name:", data.name)
  print("Repos:", data.public_repos)
end
```

### cosmic.walk - Directory Tree Walking

```lua
local walk = require("cosmic.walk")
```

Utilities for recursively walking directory trees with pattern matching.

#### Functions

```lua
walk.walk(dir: string, visitor: Visitor, ctx?: T): T
```

Recursively walks directory tree, calling visitor function for each entry.

Parameters:
- dir: Directory path to walk
- visitor: function(full_path, entry, stat, ctx) -> boolean
  - full_path: Absolute/full path to entry
  - entry: Entry name (filename or dirname)
  - stat: Stat object with :mode(), :size(), :mtim() methods
  - ctx: User-provided context (accumulator)
  - Return false to skip descending into directories
- ctx: Initial context value (can be any type)

Returns: Final context value after walking

```lua
walk.collect(dir: string, pattern: string): {string}
```

Collects all files matching Lua pattern.

Parameters:
- dir: Directory to search
- pattern: Lua pattern (e.g., "%.lua$", "^test_")

Returns: Array of matching file paths

```lua
walk.collect_all(dir: string, base?: string, files?: {string:FileInfo}): {string:FileInfo}
```

Recursively collects all files with metadata.

Returns: Table mapping relative paths to FileInfo records with mode field

#### Usage Patterns

Find all Lua files:
```lua
local walk = require("cosmic.walk")

local lua_files = walk.collect("src", "%.lua$")
for _, path in ipairs(lua_files) do
  print(path)
end
```

Custom visitor to count file sizes:
```lua
local unix = require("cosmo.unix")

local total_size = walk.walk("src", function(path, entry, stat, ctx)
  if unix.S_ISREG(stat:mode()) then
    return true, ctx + stat:size()
  end
  return true, ctx
end, 0)

print("Total size:", total_size, "bytes")
```

Collect all files with permissions:
```lua
local files = walk.collect_all("src")
for path, info in pairs(files) do
  print(string.format("%o %s", info.mode, path))
end
```

Skip certain directories:
```lua
local results = {}
walk.walk(".", function(path, entry, stat, ctx)
  if entry == "node_modules" or entry == ".git" then
    return false  -- Skip these directories
  end
  if unix.S_ISREG(stat:mode()) and entry:match("%.tl$") then
    table.insert(ctx, path)
  end
  return true
end, results)
```

### cosmic.teal - Teal Compiler Integration

```lua
local teal = require("cosmic.teal")
```

Integration layer for Teal type checking and compilation.

#### Functions

```lua
teal.compile(input_path: string, opts?: CompileOpts): CompileResult
```

Compiles Teal file to Lua.

Returns CompileResult:
```lua
{
  ok: boolean,       -- true if compilation succeeded
  code: string,      -- Generated Lua code (if ok)
  errors: {Issue}    -- Compilation errors
}
```

```lua
teal.check(input_path: string, opts?: CheckOpts): CheckResult
```

Type-checks Teal file without generating code.

Returns CheckResult:
```lua
{
  ok: boolean,        -- true if no errors
  warnings: {Issue},  -- Type warnings
  errors: {Issue}     -- Type errors
}
```

Issue type:
```lua
{
  file: string,
  line: number,
  column: number,
  message: string,
  severity: string   -- "warning" or "error"
}
```

```lua
teal.format_issues(issues: {Issue}): string
```

Formats issues for human-readable output.

```lua
teal.get_default_include_dirs(): {string}
```

Returns default type definition search paths.

#### Usage Patterns

Compile Teal to Lua:
```lua
local teal = require("cosmic.teal")

local result = teal.compile("script.tl")
if not result.ok then
  print(teal.format_issues(result.errors))
  os.exit(1)
end

-- Write compiled Lua
local cosmo = require("cosmo")
cosmo.Barf("script.lua", result.code)
```

Type check without compiling:
```lua
local result = teal.check("mycode.tl")
if not result.ok then
  io.stderr:write(teal.format_issues(result.errors))
  os.exit(1)
end

if #result.warnings > 0 then
  io.stderr:write(teal.format_issues(result.warnings))
end
```

## CLI Usage

```bash
cosmic [options] [script [args]]
```

### Options

| Option | Description |
|--------|-------------|
| `-e <stat>` | Execute Lua statement |
| `-l <name>` | Require library before script |
| `-i` | Enter interactive REPL after script |
| `-v` | Show version |
| `-h` | Show help |
| `--help=<mod>` | Show help for specific module |
| `--compile <file.tl>` | Compile Teal to Lua (output to stdout) |
| `--check <file.tl>` | Type-check Teal file |

### Examples

Execute Lua code:
```bash
cosmic -e "print('Hello')"
```

Run script with arguments:
```bash
cosmic myscript.lua arg1 arg2
```

Compile Teal to Lua:
```bash
cosmic --compile source.tl > source.lua
```

Type-check Teal code:
```bash
cosmic --check mycode.tl
```

Interactive REPL:
```bash
cosmic -i
```

Preload libraries:
```bash
cosmic -l cosmic.spawn -e "spawn({'echo', 'hello'}):wait()"
```

Use in shebang:
```lua
#!/usr/bin/env cosmic
local spawn = require("cosmic.spawn")
local handle = spawn({"git", "status"})
print(handle:read())
```

## Common Patterns

### Pattern: CLI Tool with Cosmic

```lua
#!/usr/bin/env cosmic
local spawn = require("cosmic.spawn")
local fetch = require("cosmic.fetch")
local walk = require("cosmic.walk")

-- Parse arguments
local args = {...}
if #args == 0 then
  io.stderr:write("Usage: tool <command>\n")
  os.exit(1)
end

-- Execute based on command
if args[1] == "fetch" then
  local result = fetch.Fetch(args[2])
  if not result.ok then
    io.stderr:write("Error: " .. result.error .. "\n")
    os.exit(1)
  end
  print(result.body)
elseif args[1] == "run" then
  local handle = spawn({args[2], table.unpack(args, 3)})
  local exit_code = handle:wait()
  os.exit(exit_code)
end
```

### Pattern: Build Script

```lua
local cosmo = require("cosmo")
local spawn = require("cosmic.spawn")
local walk = require("cosmic.walk")

-- Collect all Teal source files
local tl_files = walk.collect("src", "%.tl$")

-- Compile each file
for _, tl_file in ipairs(tl_files) do
  local lua_file = tl_file:gsub("%.tl$", ".lua")
  print("Compiling", tl_file, "->", lua_file)

  local handle = spawn({"cosmic", "--compile", tl_file})
  local ok, output, code = handle:read()

  if not ok then
    error("Compilation failed: " .. tl_file)
  end

  cosmo.Barf(lua_file, output)
end

print("Build complete")
```

### Pattern: Testing Framework

```lua
local spawn = require("cosmic.spawn")

local function run_test(test_file)
  local handle = spawn({"cosmic", test_file})
  local ok, output, exit_code = handle:read()

  return {
    passed = ok,
    output = output,
    exit_code = exit_code
  }
end

local tests = walk.collect("tests", "^test_.*%.lua$")
local results = {}

for _, test in ipairs(tests) do
  io.write("Running " .. test .. " ... ")
  local result = run_test(test)

  if result.passed then
    print("✓")
  else
    print("✗")
    print(result.output)
  end

  table.insert(results, {file = test, result = result})
end
```

### Pattern: HTTP API Client

```lua
local fetch = require("cosmic.fetch")
local cosmo = require("cosmo")

local function github_user(username)
  local result = fetch.Fetch(
    "https://api.github.com/users/" .. username,
    {
      headers = {
        ["Accept"] = "application/vnd.github.v3+json",
        ["User-Agent"] = "cosmic-lua"
      },
      max_attempts = 3
    }
  )

  if not result.ok then
    return nil, result.error
  end

  if result.status ~= 200 then
    return nil, "HTTP " .. result.status
  end

  return cosmo.DecodeJson(result.body)
end

local user, err = github_user("octocat")
if not user then
  error("Failed to fetch user: " .. err)
end

print("Name:", user.name)
print("Public repos:", user.public_repos)
```

## Build System Integration

cosmic-lua uses a sophisticated GNU Make-based build system with a module-oriented architecture.

### Building from Source

Requirements:
- GNU Make 4.0+
- Internet connection (downloads dependencies)

```bash
git clone https://github.com/cosmopolitan-lang/cosmic.git
cd cosmic
make build
```

The resulting binary is at `o/bin/cosmic`.

### Module System

Each module declares its dependencies, sources, and tests in a `cook.mk` file:

```makefile
modules += mymodule
mymodule_deps := cosmos tl
mymodule_tl_files := $(wildcard lib/mymodule/*.tl)
mymodule_tests := $(wildcard lib/mymodule/test_*.tl)
```

### Key Make Targets

```bash
make build      # Build cosmic binary
make test       # Run all tests
make teal       # Type-check all Teal files
make ci         # Run teal + test + build (CI pipeline)
make help       # Show all available targets
```

### Teal Configuration

The project uses `tlconfig.lua` for Teal compiler settings:

```lua
return {
  gen_target = "5.4",      -- Target Lua 5.4
  gen_compat = "off",      -- No compatibility mode
  include_dir = {"lib/types"}
}
```

Type definitions in `lib/types/` are automatically available to Teal code.

## Troubleshooting

### Command not found

If spawn fails with "command not found", either:
1. Use absolute path: `spawn({"/usr/bin/git", "status"})`
2. Ensure command is in PATH: `unix.commandv("git")` returns nil if not found

### Fetch timeouts

Increase retry attempts and delay:
```lua
fetch.Fetch(url, {max_attempts = 5, max_delay = 60})
```

### Type checking errors

Ensure type definitions are available:
```lua
local dirs = require("cosmic.teal").get_default_include_dirs()
for _, dir in ipairs(dirs) do
  print(dir)
end
```

### Binary won't execute

Make executable: `chmod +x cosmic`

On some systems, may need to allow APE execution. See https://justine.lol/ape.html

### Pipe errors (SIGPIPE)

Always read stdout/stderr before waiting:
```lua
local handle = spawn(cmd)
handle.stdout:read()  -- Read before wait()
handle:wait()
```

## Type System Guide

cosmic-lua uses Teal for static type checking. Type definitions are in `lib/types/*.d.tl`.

### Defining Types

```lua
local record Config
  host: string
  port: number
  timeout: number
end

local function connect(config: Config): boolean
  -- Implementation
end
```

### Generic Functions

```lua
local function map<T, U>(items: {T}, fn: function(T): U): {U}
  local result: {U} = {}
  for _, item in ipairs(items) do
    table.insert(result, fn(item))
  end
  return result
end
```

### Union Types

```lua
local function process(input: string | number): string
  if type(input) == "string" then
    return input
  else
    return tostring(input)
  end
end
```

### Error Returns

```lua
local function may_fail(): string, string
  if error_condition then
    return nil, "error message"
  end
  return "success"
end

local result, err = may_fail()
if not result then
  error(err)
end
```

## Performance Considerations

- **Startup time**: ~10ms due to single-file binary
- **HTTP throughput**: 1M+ requests/sec for gzip responses (leverages kernelspace copy)
- **Process spawning**: Fork is cheap due to small binary size
- **Memory usage**: Minimal baseline (~5MB for interpreter)

## Limitations

- No threads (Lua limitation)
- No async/await (use process spawning for concurrency)
- Windows support via WINE layer (may have quirks)
- APE format may require configuration on some Linux distros

## Version Information

This documentation describes cosmic-lua version 0.1.0 based on:
- Cosmopolitan Libc 2026.01.18
- Lua 5.4
- Teal 0.24.8

For latest version, see: https://github.com/cosmopolitan-lang/cosmic/releases

## Additional Resources

- GitHub Repository: https://github.com/cosmopolitan-lang/cosmic
- Cosmopolitan Libc: https://justine.lol/cosmopolitan/
- Teal Language: https://github.com/teal-language/tl
- Issue Tracker: https://github.com/cosmopolitan-lang/cosmic/issues

---

This documentation is maintained as llm.txt for LLM agent consumption. Human-readable documentation is available at docs/api/ in the repository.
